"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const index_1 = __importStar(require("../../src/index"));
const adapter_factory_1 = require("../../src/adapters/adapter-factory");
const common_1 = require("../../src/types/common");
function createAdapterStub() {
    return {
        getPlatform: () => 'test',
        isSupported: () => true,
        executeCommand: async (command) => ({
            stdout: '',
            stderr: '',
            exitCode: 0,
            platform: 'test',
            executionTime: 0,
            command
        }),
        readFile: async () => '',
        fileExists: async () => true,
        getCPUInfo: async () => ({}),
        getCPUUsage: async () => ({}),
        getCPUTemperature: async () => ([]),
        getMemoryInfo: async () => ({}),
        getMemoryUsage: async () => ({}),
        getDiskInfo: async () => ({}),
        getDiskIO: async () => ({}),
        getNetworkInterfaces: async () => ({}),
        getNetworkStats: async () => ({}),
        getProcesses: async () => ([]),
        getProcessInfo: async () => ({}),
        getSystemInfo: async () => ({}),
        getSystemLoad: async () => ({}),
        getDiskUsage: async () => ({}),
        getDiskStats: async () => ({}),
        getMounts: async () => ({}),
        getFileSystems: async () => ({}),
        getNetworkConnections: async () => ({}),
        getDefaultGateway: async () => ({}),
        getProcessList: async () => ([]),
        killProcess: async () => true,
        getProcessOpenFiles: async () => ([]),
        getProcessEnvironment: async () => ({}),
        getSystemUptime: async () => ({}),
        getSystemUsers: async () => ([]),
        getSystemServices: async () => ([]),
        getSupportedFeatures: () => ({
            cpu: { info: true, usage: true, temperature: true, frequency: true, cache: true, perCore: true, cores: true },
            memory: { info: true, usage: true, swap: true, pressure: true, detailed: true, virtual: true },
            disk: { info: true, io: true, health: true, smart: true, filesystem: true, usage: true, stats: true, mounts: true, filesystems: true },
            network: { interfaces: true, stats: true, connections: true, bandwidth: true, gateway: true },
            process: { list: true, details: true, tree: true, monitor: true, info: true, kill: true, openFiles: true, environment: true },
            system: { info: true, load: true, uptime: true, users: true, services: true }
        })
    };
}
function makeSuccessResult(data) {
    return {
        success: true,
        data,
        timestamp: Date.now(),
        cached: false,
        platform: 'test'
    };
}
describe('OSUtils 入口类', () => {
    const originalCreate = adapter_factory_1.AdapterFactory.create;
    beforeEach(() => {
        adapter_factory_1.AdapterFactory.create = () => createAdapterStub();
        adapter_factory_1.AdapterFactory.clearCache();
    });
    afterEach(() => {
        adapter_factory_1.AdapterFactory.create = originalCreate;
        adapter_factory_1.AdapterFactory.clearCache();
    });
    it('cpu/内存等监控器按需懒加载并复用实例', () => {
        const utils = new index_1.OSUtils({ platform: 'test' });
        const cpu1 = utils.cpu;
        const cpu2 = utils.cpu;
        const memory = utils.memory;
        (0, chai_1.expect)(cpu1).to.equal(cpu2);
        (0, chai_1.expect)(memory).to.not.equal(cpu1);
    });
    it('configureCache 会重建缓存并重置监控器实例', () => {
        const utils = new index_1.OSUtils({ platform: 'test' });
        const firstCpu = utils.cpu;
        utils.configureCache({ maxSize: 5, defaultTTL: 200 });
        const stats = utils.getCacheStats();
        (0, chai_1.expect)(stats?.maxSize).to.equal(5);
        const secondCpu = utils.cpu;
        (0, chai_1.expect)(secondCpu).to.not.equal(firstCpu);
    });
    it('overview 聚合各监控器返回的数据', async () => {
        const utils = new index_1.OSUtils({ platform: 'test' });
        utils._system = {
            info: () => Promise.resolve(makeSuccessResult({ hostname: 'test-host' })),
            destroy: () => undefined
        };
        utils._cpu = {
            usage: () => Promise.resolve(makeSuccessResult(42)),
            destroy: () => undefined
        };
        utils._memory = {
            summary: () => Promise.resolve(makeSuccessResult({ total: '16 GB' })),
            destroy: () => undefined
        };
        utils._disk = {
            spaceOverview: () => Promise.resolve(makeSuccessResult({ free: '100 GB' })),
            healthCheck: () => Promise.resolve(makeSuccessResult({ status: 'healthy', issues: [] })),
            destroy: () => undefined
        };
        utils._network = {
            overview: () => Promise.resolve(makeSuccessResult({
                interfaces: 3,
                activeInterfaces: 2,
                totalRxBytes: new common_1.DataSize(1024),
                totalTxBytes: new common_1.DataSize(2048),
                totalPackets: 500,
                totalErrors: 1
            })),
            healthCheck: () => Promise.resolve(makeSuccessResult({ status: 'warning', issues: ['latency'] })),
            destroy: () => undefined
        };
        utils._process = {
            stats: () => Promise.resolve(makeSuccessResult({ running: 120 })),
            destroy: () => undefined
        };
        const overview = await utils.overview();
        (0, chai_1.expect)(overview.system?.hostname).to.equal('test-host');
        (0, chai_1.expect)(overview.cpu?.usage).to.equal(42);
        (0, chai_1.expect)(overview.network?.totalErrors).to.equal(1);
        (0, chai_1.expect)(overview.processes?.running).to.equal(120);
    });
    it('healthCheck 汇总健康状态并计算总体结果', async () => {
        const utils = new index_1.OSUtils({ platform: 'test' });
        utils._system = {
            info: () => Promise.resolve(makeSuccessResult({})),
            healthCheck: () => Promise.resolve(makeSuccessResult({ status: 'healthy', issues: [] })),
            destroy: () => undefined
        };
        utils._disk = {
            healthCheck: () => Promise.resolve(makeSuccessResult({ status: 'critical', issues: ['disk failure'] })),
            destroy: () => undefined
        };
        utils._network = {
            healthCheck: () => Promise.resolve(makeSuccessResult({ status: 'warning', issues: ['latency'] })),
            destroy: () => undefined
        };
        const health = await utils.healthCheck();
        (0, chai_1.expect)(health.status).to.equal('critical');
        (0, chai_1.expect)(health.issues).to.include('disk failure');
        (0, chai_1.expect)(health.details?.network?.status).to.equal('warning');
    });
    it('createOSUtils 工厂函数返回 OSUtils 实例', () => {
        const instance = (0, index_1.createOSUtils)({ platform: 'test', debug: true });
        (0, chai_1.expect)(instance).to.be.instanceOf(index_1.OSUtils);
        (0, chai_1.expect)(index_1.default).to.equal(index_1.OSUtils);
    });
});
//# sourceMappingURL=index.test.js.map