"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const process_monitor_1 = require("../../../src/monitors/process-monitor");
const SUPPORTED_FEATURES = {
    cpu: {
        info: false,
        usage: false,
        temperature: false,
        frequency: false,
        cache: false,
        perCore: false,
        cores: false
    },
    memory: {
        info: false,
        usage: false,
        swap: false,
        pressure: false,
        detailed: false,
        virtual: false
    },
    disk: {
        info: false,
        io: false,
        health: false,
        smart: false,
        filesystem: false,
        usage: false,
        stats: false,
        mounts: false,
        filesystems: false
    },
    network: {
        interfaces: false,
        stats: false,
        connections: false,
        bandwidth: false,
        gateway: false
    },
    process: {
        list: true,
        details: true,
        tree: true,
        monitor: true,
        info: true,
        kill: true,
        openFiles: true,
        environment: true
    },
    system: {
        info: false,
        load: false,
        uptime: false,
        users: false,
        services: false
    }
};
class ProcessAdapterStub {
    constructor(options = {}) {
        this.options = options;
        this.processListCalls = 0;
        this.processInfoCalls = 0;
    }
    getPlatform() {
        return 'test-platform';
    }
    isSupported(feature) {
        return feature.startsWith('process');
    }
    async executeCommand(command, options) {
        return {
            stdout: '',
            stderr: '',
            exitCode: 0,
            platform: this.getPlatform(),
            executionTime: 0,
            command
        };
    }
    async readFile() { return ''; }
    async fileExists() { return false; }
    async getCPUInfo() { return {}; }
    async getCPUUsage() { return {}; }
    async getCPUTemperature() { return {}; }
    async getMemoryInfo() { return {}; }
    async getMemoryUsage() { return {}; }
    async getDiskInfo() { return []; }
    async getDiskIO() { return []; }
    async getNetworkInterfaces() { return []; }
    async getNetworkStats() { return []; }
    async getProcesses() { return this.getProcessList(); }
    async getProcessInfo(pid) {
        this.processInfoCalls += 1;
        if (!this.options.processInfo) {
            return null;
        }
        return this.options.processInfo[pid] ?? null;
    }
    async getSystemInfo() { return {}; }
    async getSystemLoad() { return {}; }
    async getDiskUsage() { return []; }
    async getDiskStats() { return []; }
    async getMounts() { return []; }
    async getFileSystems() { return []; }
    async getNetworkConnections() { return []; }
    async getDefaultGateway() { return null; }
    async getProcessList() {
        this.processListCalls += 1;
        return this.options.processes ?? [];
    }
    async killProcess() { return true; }
    async getProcessOpenFiles() { return []; }
    async getProcessEnvironment() { return {}; }
    async getSystemUptime() { return 0; }
    async getSystemUsers() { return []; }
    async getSystemServices() { return []; }
    getSupportedFeatures() {
        return SUPPORTED_FEATURES;
    }
}
describe('ProcessMonitor', function () {
    it('缓存命中时仍应返回空进程结果', async function () {
        const adapter = new ProcessAdapterStub();
        const monitor = new process_monitor_1.ProcessMonitor(adapter);
        const first = await monitor.byPid(99999);
        const second = await monitor.byPid(99999);
        if (!first.success) {
            chai_1.expect.fail('第一次调用应成功返回');
            return;
        }
        (0, chai_1.expect)(first.data).to.be.null;
        if (!second.success) {
            chai_1.expect.fail('第二次调用应成功返回缓存结果');
            return;
        }
        (0, chai_1.expect)(second.data).to.be.null;
        (0, chai_1.expect)(second.cached).to.be.true;
        (0, chai_1.expect)(adapter.processInfoCalls).to.equal(1);
    });
    it('topByCpu 应忽略 maxResults 限制以返回真实的高占用进程', async function () {
        const processes = Array.from({ length: 5 }).map((_, index) => ({
            pid: index + 1,
            ppid: 0,
            name: `process-${index}`,
            command: `process-${index}`,
            state: 'running',
            cpuUsage: index * 20,
            memoryUsage: (index + 1) * 1024,
            memoryPercentage: index * 5,
            startTime: Date.now() - 1000
        }));
        const adapter = new ProcessAdapterStub({ processes });
        const monitor = new process_monitor_1.ProcessMonitor(adapter, { maxResults: 2 });
        const topResult = await monitor.topByCpu(1);
        if (!topResult.success || !topResult.data) {
            chai_1.expect.fail('获取Top进程失败');
            return;
        }
        (0, chai_1.expect)(topResult.data).to.have.lengthOf(1);
        (0, chai_1.expect)(topResult.data[0].pid).to.equal(5);
        (0, chai_1.expect)(adapter.processListCalls).to.equal(1);
    });
});
//# sourceMappingURL=process-monitor.test.js.map