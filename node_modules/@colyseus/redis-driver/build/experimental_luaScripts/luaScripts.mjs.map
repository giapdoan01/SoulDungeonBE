{
  "version": 3,
  "sources": ["../../src/experimental_luaScripts/luaScripts.ts"],
  "sourcesContent": ["/**\n * Lua scripts for Redis-based room cache filtering and sorting.\n * These scripts move filtering/sorting logic from Node.js to Redis,\n * eliminating the need to load all room caches into memory.\n */\n\n/**\n * Lua script that filters and sorts room caches.\n *\n * KEYS[1]: The roomcaches hash key\n * ARGV[1]: JSON-encoded conditions object\n * ARGV[2]: JSON-encoded sort options object (optional, can be empty string)\n *\n * Returns: Array of JSON-encoded room cache strings that match the conditions\n */\nexport const FILTER_AND_SORT_SCRIPT = `\nlocal roomcaches_key = KEYS[1]\nlocal conditions_json = ARGV[1]\nlocal sort_options_json = ARGV[2]\n\n-- Parse conditions\nlocal conditions = {}\nif conditions_json and conditions_json ~= '' then\n  conditions = cjson.decode(conditions_json)\nend\n\n-- Parse sort options\nlocal sort_options = {}\nif sort_options_json and sort_options_json ~= '' then\n  sort_options = cjson.decode(sort_options_json)\nend\n\n-- Get all room caches\nlocal all_rooms = redis.call('HGETALL', roomcaches_key)\nlocal matching_rooms = {}\n\n-- Helper function to check if a room matches conditions\nlocal function matches_conditions(room, conditions)\n  for field, expected_value in pairs(conditions) do\n    local actual_value = room[field]\n\n    -- If field not in room, check metadata\n    if actual_value == nil and room.metadata then\n      actual_value = room.metadata[field]\n    end\n\n    -- If still nil and expected value exists, no match\n    if actual_value == nil then\n      return false\n    end\n\n    -- Compare values\n    if actual_value ~= expected_value then\n      return false\n    end\n  end\n  return true\nend\n\n-- Micro optimization: filter by room name before parsing JSON\nlocal room_name_filter = nil\nif conditions.name then\n  room_name_filter = '\"name\":\"' .. conditions.name .. '\"'\nend\n\n-- Iterate through room caches (HGETALL returns field, value, field, value, ...)\nfor i = 1, #all_rooms, 2 do\n  local room_id = all_rooms[i]\n  local room_json = all_rooms[i + 1]\n\n  -- Skip rooms that don't match the name filter (before parsing JSON)\n  if room_name_filter == nil or string.find(room_json, room_name_filter, 1, true) then\n    local success, room = pcall(cjson.decode, room_json)\n    if success and room then\n      if matches_conditions(room, conditions) then\n        table.insert(matching_rooms, { data = room, json = room_json, idx = i })\n      end\n    end\n  end\nend\n\n-- Sort if sort options provided\nif next(sort_options) ~= nil then\n  table.sort(matching_rooms, function(a, b)\n    for field, direction in pairs(sort_options) do\n      -- Normalize direction to 1 or -1\n      local dir = 1\n      if direction == -1 or direction == 'desc' or direction == 'descending' then\n        dir = -1\n      end\n\n      -- Get values from room or metadata\n      local val_a = a.data[field]\n      if val_a == nil and a.data.metadata then\n        val_a = a.data.metadata[field]\n      end\n\n      local val_b = b.data[field]\n      if val_b == nil and b.data.metadata then\n        val_b = b.data.metadata[field]\n      end\n\n      -- Handle nil values (nil < any value)\n      if val_a == nil and val_b ~= nil then\n        return dir == 1\n      elseif val_a ~= nil and val_b == nil then\n        return dir == -1\n      elseif val_a ~= nil and val_b ~= nil and val_a ~= val_b then\n        if dir == 1 then\n          return val_a < val_b\n        else\n          return val_a > val_b\n        end\n      end\n      -- If equal, continue to next sort field\n    end\n    -- Fallback: preserve original insertion order for stable sorting\n    return a.idx < b.idx\n  end)\nend\n\n-- Return array of JSON strings\nlocal results = {}\nfor _, room in ipairs(matching_rooms) do\n  table.insert(results, room.json)\nend\n\nreturn results\n`;\n\n/**\n * Lua script that finds the first matching room cache.\n * Optimized to return early after finding the first match.\n *\n * KEYS[1]: The roomcaches hash key\n * ARGV[1]: JSON-encoded conditions object\n * ARGV[2]: JSON-encoded sort options object (optional, can be empty string)\n *\n * Returns: JSON-encoded room cache string of the first match, or nil if no match\n */\nexport const FIND_ONE_SCRIPT = `\nlocal roomcaches_key = KEYS[1]\nlocal conditions_json = ARGV[1]\nlocal sort_options_json = ARGV[2]\n\n-- Parse conditions\nlocal conditions = {}\nif conditions_json and conditions_json ~= '' then\n  conditions = cjson.decode(conditions_json)\nend\n\n-- Parse sort options\nlocal sort_options = {}\nif sort_options_json and sort_options_json ~= '' then\n  sort_options = cjson.decode(sort_options_json)\nend\n\n-- Get all room caches\nlocal all_rooms = redis.call('HGETALL', roomcaches_key)\n\n-- Helper function to check if a room matches conditions\nlocal function matches_conditions(room, conditions)\n  for field, expected_value in pairs(conditions) do\n    local actual_value = room[field]\n\n    -- If field not in room, check metadata\n    if actual_value == nil and room.metadata then\n      actual_value = room.metadata[field]\n    end\n\n    -- If still nil and expected value exists, no match\n    if actual_value == nil then\n      return false\n    end\n\n    -- Compare values\n    if actual_value ~= expected_value then\n      return false\n    end\n  end\n  return true\nend\n\n-- Micro optimization: filter by room name before parsing JSON\nlocal room_name_filter = nil\nif conditions.name then\n  room_name_filter = '\"name\":\"' .. conditions.name .. '\"'\nend\n\n-- If no sort options, we can return early on first match\nif next(sort_options) == nil then\n  for i = 1, #all_rooms, 2 do\n    local room_id = all_rooms[i]\n    local room_json = all_rooms[i + 1]\n\n    -- Skip rooms that don't match the name filter (before parsing JSON)\n    if room_name_filter == nil or string.find(room_json, room_name_filter, 1, true) then\n      local success, room = pcall(cjson.decode, room_json)\n      if success and room and matches_conditions(room, conditions) then\n        return room_json\n      end\n    end\n  end\n  return nil\nend\n\n-- With sort options, we need to find all matches first, then sort\nlocal matching_rooms = {}\n\nfor i = 1, #all_rooms, 2 do\n  local room_id = all_rooms[i]\n  local room_json = all_rooms[i + 1]\n\n  -- Skip rooms that don't match the name filter (before parsing JSON)\n  if room_name_filter == nil or string.find(room_json, room_name_filter, 1, true) then\n    local success, room = pcall(cjson.decode, room_json)\n    if success and room then\n      if matches_conditions(room, conditions) then\n        table.insert(matching_rooms, { data = room, json = room_json, idx = i })\n      end\n    end\n  end\nend\n\nif #matching_rooms == 0 then\n  return nil\nend\n\n-- Sort matching rooms\ntable.sort(matching_rooms, function(a, b)\n  for field, direction in pairs(sort_options) do\n    -- Normalize direction to 1 or -1\n    local dir = 1\n    if direction == -1 or direction == 'desc' or direction == 'descending' then\n      dir = -1\n    end\n\n    -- Get values from room or metadata\n    local val_a = a.data[field]\n    if val_a == nil and a.data.metadata then\n      val_a = a.data.metadata[field]\n    end\n\n    local val_b = b.data[field]\n    if val_b == nil and b.data.metadata then\n      val_b = b.data.metadata[field]\n    end\n\n    -- Handle nil values (nil < any value)\n    if val_a == nil and val_b ~= nil then\n      return dir == 1\n    elseif val_a ~= nil and val_b == nil then\n      return dir == -1\n    elseif val_a ~= nil and val_b ~= nil and val_a ~= val_b then\n      if dir == 1 then\n        return val_a < val_b\n      else\n        return val_a > val_b\n      end\n    end\n    -- If equal, continue to next sort field\n  end\n  -- Fallback: preserve original insertion order for stable sorting\n  return a.idx < b.idx\nend)\n\nreturn matching_rooms[1].json\n`;\n"],
  "mappings": ";AAeO,IAAM,yBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6H/B,IAAM,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;",
  "names": []
}
