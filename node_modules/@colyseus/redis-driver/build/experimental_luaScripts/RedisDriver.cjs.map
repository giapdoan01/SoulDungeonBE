{
  "version": 3,
  "sources": ["../../src/experimental_luaScripts/RedisDriver.ts"],
  "sourcesContent": ["import {\n  Redis,\n  Cluster,\n  type ClusterNode,\n  type ClusterOptions,\n  type RedisOptions\n} from 'ioredis';\n\nimport {\n  type IRoomCache,\n  type MatchMakerDriver,\n  type SortOptions,\n  debugMatchMaking,\n  initializeRoomCache,\n} from '@colyseus/core';\n\nimport { FILTER_AND_SORT_SCRIPT, FIND_ONE_SCRIPT } from './luaScripts.ts';\n\nconst ROOMCACHES_KEY = 'roomcaches';\n\nexport class RedisDriver implements MatchMakerDriver {\n  private readonly _client: Redis | Cluster;\n\n  // Cache concurrent filterAndSort requests to avoid redundant Redis calls\n  private _pendingFilterRequests: Map<string, Promise<string[]>> = new Map();\n  private _pendingFindOneRequests: Map<string, Promise<string | null>> = new Map();\n\n  constructor(options?: number | string | RedisOptions | ClusterNode[], clusterOptions?: ClusterOptions) {\n    this._client = (Array.isArray(options))\n      ? new Cluster(options, clusterOptions)\n      : new Redis(options as RedisOptions);\n  }\n\n  public async has(roomId: string) {\n    return await this._client.hexists(ROOMCACHES_KEY, roomId) === 1;\n  }\n\n  public async query(conditions: Partial<IRoomCache>, sortOptions?: SortOptions) {\n    const conditionsJson = JSON.stringify(conditions || {});\n    const sortOptionsJson = sortOptions ? JSON.stringify(sortOptions) : '';\n    const cacheKey = `${conditionsJson}:${sortOptionsJson}`;\n\n    // Check if there's already a pending request with the same parameters\n    let pendingRequest = this._pendingFilterRequests.get(cacheKey);\n\n    if (!pendingRequest) {\n      // Create new request and cache it\n      pendingRequest = (this._client as any).filterAndSort(\n        ROOMCACHES_KEY,\n        conditionsJson,\n        sortOptionsJson\n      ) as Promise<string[]>;\n\n      this._pendingFilterRequests.set(cacheKey, pendingRequest);\n\n      // Clean up cache after request completes\n      pendingRequest.finally(() => {\n        this._pendingFilterRequests.delete(cacheKey);\n      });\n    }\n\n    const results = await pendingRequest;\n    return results.map((roomcache) => initializeRoomCache(JSON.parse(roomcache)));\n  }\n\n  public async cleanup(processId: string) {\n    const cachedRooms = await this.query({ processId });\n    debugMatchMaking(\"removing stale rooms by processId %s (%s rooms found)\", processId, cachedRooms.length);\n\n    const itemsPerCommand = 500;\n\n    // remove rooms in batches of 500\n    for (let i = 0; i < cachedRooms.length; i += itemsPerCommand) {\n      await this._client.hdel(ROOMCACHES_KEY, ...cachedRooms.slice(i, i + itemsPerCommand).map((room) => room.roomId));\n    }\n  }\n\n  public async findOne(conditions: Partial<IRoomCache>, sortOptions?: SortOptions): Promise<IRoomCache> {\n    if (typeof conditions.roomId !== 'undefined') {\n      // get room by roomId\n\n      //\n      // TODO: refactor driver APIs.\n      // the API here is legacy from MongooseDriver which made sense on versions <= 0.14.0\n      //\n\n      const roomcache = await this._client.hget(ROOMCACHES_KEY, conditions.roomId);\n      if (roomcache) {\n        return initializeRoomCache(JSON.parse(roomcache));\n      }\n      return undefined;\n\n    } else {\n      // Use Lua script to find first matching room in Redis\n      const conditionsJson = JSON.stringify(conditions || {});\n      const sortOptionsJson = sortOptions ? JSON.stringify(sortOptions) : '';\n      const cacheKey = `${conditionsJson}:${sortOptionsJson}`;\n\n      // Check if there's already a pending request with the same parameters\n      let pendingRequest = this._pendingFindOneRequests.get(cacheKey);\n\n      if (!pendingRequest) {\n        // Create new request and cache it\n        pendingRequest = (this._client as any).findOneRoom(\n          ROOMCACHES_KEY,\n          conditionsJson,\n          sortOptionsJson\n        ) as Promise<string | null>;\n\n        this._pendingFindOneRequests.set(cacheKey, pendingRequest);\n\n        // Clean up cache after request completes\n        pendingRequest.finally(() => {\n          this._pendingFindOneRequests.delete(cacheKey);\n        });\n      }\n\n      const result = await pendingRequest;\n\n      if (result) {\n        return initializeRoomCache(JSON.parse(result));\n      }\n      return undefined;\n    }\n  }\n\n  public async update(room: IRoomCache, operations: Partial<{ $set: Partial<IRoomCache>, $inc: Partial<IRoomCache> }>) {\n    if (operations.$set) {\n      for (const field in operations.$set) {\n        if (operations.$set.hasOwnProperty(field)) {\n          room[field] = operations.$set[field];\n        }\n      }\n    }\n\n    if (operations.$inc) {\n      for (const field in operations.$inc) {\n        if (operations.$inc.hasOwnProperty(field)) {\n          room[field] += operations.$inc[field];\n        }\n      }\n    }\n\n    await this._client.hset(ROOMCACHES_KEY, room.roomId, JSON.stringify(room));\n    return true;\n  }\n\n  public async persist(room: IRoomCache, _: boolean = false) {\n    if (!room.roomId) {\n      debugMatchMaking(\"RedisDriver: can't .persist() without a `roomId`\");\n      return false;\n    }\n\n    await this._client.hset(ROOMCACHES_KEY, room.roomId, JSON.stringify(room));\n    return true;\n  }\n\n  public async remove(roomId: string) {\n    const result = await this._client.hdel(ROOMCACHES_KEY, roomId);\n    return result > 0;\n  }\n\n  public async shutdown() {\n    await this._client.quit();\n  }\n\n  public async boot() {\n    // Define custom Lua commands for filtering and sorting\n    // ioredis defineCommand works for both Redis and Cluster instances\n    (this._client as any).defineCommand('filterAndSort', {\n      numberOfKeys: 1,\n      lua: FILTER_AND_SORT_SCRIPT,\n    });\n\n    (this._client as any).defineCommand('findOneRoom', {\n      numberOfKeys: 1,\n      lua: FIND_ONE_SCRIPT,\n    });\n  }\n\n  //\n  // only relevant for the test-suite.\n  // not used during runtime.\n  //\n  public clear() {\n    this._client.del(ROOMCACHES_KEY);\n  }\n\n}\n"],
  "mappings": "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",
  "names": []
}
