{"version":3,"file":"cli.cjs","sources":["../../src/codegen/argv.ts","../../src/codegen/types.ts","../../src/codegen/parser.ts","../../src/codegen/languages/csharp.ts","../../src/codegen/languages/cpp.ts","../../src/codegen/languages/haxe.ts","../../src/codegen/languages/ts.ts","../../src/codegen/languages/js.ts","../../src/codegen/languages/java.ts","../../src/codegen/languages/lua.ts","../../src/codegen/api.ts","../../src/codegen/cli.ts"],"sourcesContent":["/**\n * @author Ethan Davis\n * https://github.com/ethanent/gar\n */\nexport default (sargs: string[]): any => {\n\tlet props: any = {}\n\tlet lones: any = []\n\n\tconst convertIfApplicable = (value: any) => (isNaN(value) ? (value.toString().toLowerCase() === 'true' ? true : (value.toString().toLowerCase() === 'false' ? false : value)) : Number(value))\n\tconst removeStartHyphens = (value: string) => value.replace(/^\\-+/g, '')\n\n\tfor (let i = 0; i < sargs.length; i++) {\n\t\tconst equalsIndex = sargs[i].indexOf('=')\n\t\tconst isNextRefProp = sargs[i].charAt(0) === '-' && sargs.length - 1 >= i + 1 && sargs[i + 1].indexOf('=') === -1 && sargs[i + 1].charAt(0) !== '-'\n\t\tconst argName = equalsIndex === -1 ? removeStartHyphens(sargs[i]) : removeStartHyphens(sargs[i].slice(0, equalsIndex))\n\n\t\tif (equalsIndex !== -1) {\n\t\t\tprops[argName] = convertIfApplicable(sargs[i].slice(equalsIndex + 1))\n\t\t}\n\t\telse if (isNextRefProp) {\n\t\t\tprops[argName] = convertIfApplicable(sargs[i + 1])\n\t\t\ti++\n\t\t} else if (sargs[i].charAt(0) === '-') {\n\t\t\tif (sargs[i].charAt(1) === '-') {\n\t\t\t\tprops[argName] = true\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (let b = 0; b < argName.length; b++) {\n\t\t\t\t\tprops[argName.charAt(b)] = true\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlones.push(convertIfApplicable(argName))\n\t\t}\n\t}\n\n\treturn Object.assign(props, {\n\t\t'_': lones\n\t})\n}\n","import * as fs from \"fs\";\nimport * as path from \"path\";\n\nif (typeof(__dirname) === \"undefined\") {\n    global.__dirname = path.dirname(new URL(import.meta.url).pathname);\n}\n\nconst VERSION = JSON.parse(fs.readFileSync(__dirname + \"/../../package.json\").toString()).version;\nconst COMMENT_HEADER = `\nTHIS FILE HAS BEEN GENERATED AUTOMATICALLY\nDO NOT CHANGE IT MANUALLY UNLESS YOU KNOW WHAT YOU'RE DOING\n\nGENERATED USING @colyseus/schema ${VERSION}\n`;\n\nexport function getCommentHeader(singleLineComment: string = \"//\") {\n    return `${COMMENT_HEADER.split(\"\\n\").map(line => `${singleLineComment} ${line}`).join(\"\\n\")}`;\n}\n\nexport class Context {\n    classes: Class[] = [];\n    interfaces: Interface[] = [];\n    enums: Enum[] = [];\n\n    getStructures() {\n        return {\n            classes: this.classes.filter(klass => {\n                if (this.isSchemaClass(klass)) {\n                    return true;\n\n                } else {\n                    let parentClass = klass;\n                    while (parentClass = this.getParentClass(parentClass)) {\n                        if (this.isSchemaClass(parentClass)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }),\n            interfaces: this.interfaces,\n            enums: this.enums,\n        };\n    }\n\n    addStructure(structure: IStructure) {\n        if (structure.context === this) { return; } // skip if already added.\n        structure.context = this;\n\n        if (structure instanceof Class) {\n            this.classes.push(structure);\n        } else if (structure instanceof Interface) {\n            this.interfaces.push(structure);\n        } else if (structure instanceof Enum) {\n            this.enums.push(structure);\n        }\n    }\n\n    private getParentClass(klass: Class) {\n        return this.classes.find(c => c.name === klass.extends);\n    }\n\n    private isSchemaClass(klass: Class) {\n        let isSchema: boolean = false;\n\n        let currentClass = klass;\n        while (!isSchema && currentClass) {\n            //\n            // TODO: ideally we should check for actual @colyseus/schema module\n            // reference rather than arbitrary strings.\n            //\n            isSchema = (\n                currentClass.extends === \"Schema\" ||\n                currentClass.extends === \"schema.Schema\" ||\n                currentClass.extends === \"Schema.Schema\"\n            );\n\n            //\n            // When extending from `schema.Schema`, it is required to\n            // normalize as \"Schema\" for code generation.\n            //\n            if (currentClass === klass && isSchema) {\n                klass.extends = \"Schema\";\n            }\n\n            currentClass = this.getParentClass(currentClass);\n        }\n\n        return isSchema;\n    }\n}\n\nexport interface IStructure {\n    context: Context;\n    name: string;\n    properties: Property[];\n    addProperty(property: Property): void;\n}\n\nexport class Interface implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n\n    addProperty(property: Property): void {\n        if (property.type.indexOf(\"[]\") >= 0) {\n            // is array!\n            property.childType = property.type.match(/([^\\[]+)/i)[1];\n            property.type = \"array\";\n            this.properties.push(property);\n\n        } else {\n            this.properties.push(property);\n        }\n    }\n}\n\nexport class Class implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n    extends: string;\n\n    addProperty(property: Property) {\n        property.index = this.properties.length;\n        this.properties.push(property);\n    }\n\n    postProcessing() {\n        /**\n         * Ensure the proprierties `index` are correct using inheritance\n         */\n        let parentKlass: Class = this;\n\n        while (\n            parentKlass &&\n            (parentKlass = this.context.classes.find(k => k.name === parentKlass.extends))\n        ) {\n            this.properties.forEach(prop => {\n                prop.index += parentKlass.properties.length;\n            });\n        }\n    }\n}\n\nexport class Enum implements IStructure {\n    context: Context;\n    name: string;\n    properties: Property[] = [];\n\n    addProperty(property: Property) {\n        this.properties.push(property);\n    }\n}\n\nexport class Property {\n    index: number;\n    name: string;\n    type: string;\n    childType: string;\n    deprecated?: boolean;\n}\n\nexport interface File {\n    name: string\n    content: string;\n}\n\nexport function getInheritanceTree(klass: Class, allClasses: Class[], includeSelf: boolean = true) {\n    let currentClass = klass;\n    let inheritanceTree: Class[] = [];\n\n    if (includeSelf) {\n        inheritanceTree.push(currentClass);\n    }\n\n    while (currentClass.extends !== \"Schema\") {\n        currentClass = allClasses.find(klass => klass.name == currentClass.extends);\n        inheritanceTree.push(currentClass);\n    }\n\n    return inheritanceTree;\n}\n","import * as ts from \"typescript\";\nimport * as path from \"path\";\nimport { readFileSync } from \"fs\";\nimport { IStructure, Class, Interface, Property, Context, Enum } from \"./types.js\";\n\nlet currentStructure: IStructure;\nlet currentProperty: Property;\n\nlet globalContext: Context;\n\nfunction defineProperty(property: Property, initializer: any) {\n    if (ts.isIdentifier(initializer)) {\n        property.type = \"ref\";\n        property.childType = initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {\n        property.type = initializer.properties[0].name.text;\n        property.childType = initializer.properties[0].initializer.text;\n\n    } else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {\n        property.type = \"array\";\n        property.childType = initializer.elements[0].text;\n\n    } else {\n        property.type = initializer.text;\n    }\n}\n\nfunction inspectNode(node: ts.Node, context: Context, decoratorName: string) {\n    switch (node.kind) {\n        case ts.SyntaxKind.ImportClause:\n            const specifier = (node.parent as any).moduleSpecifier;\n            if (specifier && (specifier.text as string).startsWith('.')) {\n                const currentDir = path.dirname(node.getSourceFile().fileName);\n                const pathToImport = path.resolve(currentDir, specifier.text);\n                parseFiles([pathToImport], decoratorName, globalContext);\n            }\n            break;\n\n        case ts.SyntaxKind.ClassDeclaration:\n            currentStructure = new Class();\n\n            const heritageClauses = (node as ts.ClassLikeDeclarationBase).heritageClauses;\n            if (heritageClauses && heritageClauses.length > 0) {\n                (currentStructure as Class).extends = heritageClauses[0].types[0].expression.getText();\n            }\n\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n            //\n            // Only generate Interfaces if it has \"Message\" on its name.\n            // Example: MyMessage\n            //\n            const interfaceName = (node as ts.TypeParameterDeclaration).name.escapedText.toString();\n            if (interfaceName.indexOf(\"Message\") !== -1) {\n                currentStructure = new Interface();\n                currentStructure.name = interfaceName;\n\n                context.addStructure(currentStructure);\n            }\n            break;\n\n        case ts.SyntaxKind.EnumDeclaration:\n            const enumName = (\n                node as ts.EnumDeclaration\n            ).name.escapedText.toString();\n            currentStructure = new Enum();\n            currentStructure.name = enumName;\n            context.addStructure(currentStructure);\n            break;\n\n        case ts.SyntaxKind.ExtendsKeyword:\n            // console.log(node.getText());\n            break;\n\n        case ts.SyntaxKind.PropertySignature:\n            if (currentStructure instanceof Interface) {\n                const interfaceDeclaration = node.parent;\n\n                if (\n                    currentStructure.name !== (interfaceDeclaration as ts.TypeParameterDeclaration).name.escapedText.toString()\n                ) {\n                    // skip if property if for a another interface than the one we're interested in.\n                    break;\n                }\n\n                // define a property of an interface\n                const property = new Property();\n                property.name = (node as any).name.escapedText.toString();\n                property.type = (node as any).type.getText();\n                currentStructure.addProperty(property);\n            }\n            break;\n\n        case ts.SyntaxKind.Identifier:\n            if (\n                node.getText() === \"deprecated\" &&\n                node.parent.kind !== ts.SyntaxKind.ImportSpecifier\n            ) {\n                currentProperty = new Property();\n                currentProperty.deprecated = true;\n                break;\n            }\n\n            if (node.getText() === decoratorName) {\n                const prop: any = node.parent?.parent?.parent;\n                const propDecorator = getDecorators(prop);\n                const hasExpression = prop?.expression?.arguments;\n                const hasDecorator = (propDecorator?.length > 0);\n\n                /**\n                 * neither a `@type()` decorator or `type()` call. skip.\n                 */\n                if (!hasDecorator && !hasExpression) {\n                    break;\n                }\n\n                // using as decorator\n                if (propDecorator) {\n                    /**\n                     * Calling `@type()` as decorator\n                     */\n                    const typeDecorator: any = propDecorator.find((decorator => {\n                        return (decorator.expression as any).expression.escapedText === decoratorName;\n                    })).expression;\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = typeDecorator.arguments[0];\n                    defineProperty(property, typeArgument);\n\n                } else if (\n                    prop.expression.arguments?.[1] &&\n                    prop.expression.expression.arguments?.[0]\n                ) {\n                    /**\n                     * Calling `type()` as a regular method\n                     */\n                    const property = currentProperty || new Property();\n                    property.name = prop.expression.arguments[1].text;\n                    currentStructure.addProperty(property);\n\n                    const typeArgument = prop.expression.expression.arguments[0];\n                    defineProperty(property, typeArgument);\n                }\n\n            } else if (\n                node.getText() === \"setFields\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * Metadata.setFields(klassName, { ... })\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                /**\n                 * Skip if @codegen-ignore comment is found before the call expression\n                 * TODO: currently, if @codegen-ignore is on the file, it will skip all the setFields calls.\n                 */\n                const sourceFile = node.getSourceFile();\n                const fullText = sourceFile.getFullText();\n                const nodeStart = callExpression.getFullStart();\n                const textBeforeNode = fullText.substring(0, nodeStart);\n                if (textBeforeNode.includes('@codegen-ignore')) {\n                    break;\n                }\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const classNameNode = callExpression.arguments[0];\n                const className = ts.isClassExpression(classNameNode)\n                    ? classNameNode.name?.escapedText.toString()\n                    : classNameNode.getText();\n\n                // skip if no className is provided\n                if (!className) { break; }\n\n                if (currentStructure?.name !== className) {\n                    currentStructure = new Class();\n                }\n                context.addStructure(currentStructure);\n                (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n\n                    currentStructure.addProperty(property);\n                    defineProperty(property, prop.initializer);\n                }\n\n            } else if (\n                node.getText() === \"defineTypes\" &&\n                (\n                    node.parent.kind === ts.SyntaxKind.CallExpression ||\n                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression\n                )\n            ) {\n                /**\n                 * JavaScript source file (`.js`)\n                 * Using `defineTypes()`\n                 */\n                const callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)\n                    ? node.parent.parent as ts.CallExpression\n                    : node.parent as ts.CallExpression;\n\n                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {\n                    break;\n                }\n\n                const className = callExpression.arguments[0].getText()\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[1] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n                    currentStructure.addProperty(property);\n\n                    defineProperty(property, prop.initializer);\n                }\n\n            }\n\n            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {\n                currentStructure.name = node.getText();\n            }\n\n            currentProperty = undefined;\n\n            break;\n\n        case ts.SyntaxKind.CallExpression:\n            /**\n             * Defining schema via `schema.schema({ ... })`\n             * - schema.schema({})\n             * - schema({})\n             * - ClassName.extends({})\n             */\n            if (\n                (\n                    (\n                        (node as ts.CallExpression).expression?.getText() === \"schema.schema\" ||\n                        (node as ts.CallExpression).expression?.getText() === \"schema\"\n                    ) ||\n                    (\n                        (node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1\n                    )\n                ) &&\n                (node as ts.CallExpression).arguments[0].kind === ts.SyntaxKind.ObjectLiteralExpression\n            ) {\n                const callExpression = node as ts.CallExpression;\n\n                let className = callExpression.arguments[1]?.getText();\n\n                if (!className && callExpression.parent.kind === ts.SyntaxKind.VariableDeclaration) {\n                    className = (callExpression.parent as ts.VariableDeclaration).name?.getText();\n                }\n\n                // skip if no className is provided\n                if (!className) { break; }\n\n                if (currentStructure?.name !== className) {\n                    currentStructure = new Class();\n                    context.addStructure(currentStructure);\n                }\n\n                if ((node as ts.CallExpression).expression?.getText().indexOf(\".extends\") !== -1) {\n                    // if it's using `.extends({})`\n                    const extendsClass = (node as any).expression?.expression?.escapedText;\n\n                    // skip if no extendsClass is provided\n                    if (!extendsClass) { break; }\n                    (currentStructure as Class).extends = extendsClass;\n\n                } else {\n                    // if it's using `schema({})`\n                    (currentStructure as Class).extends = \"Schema\"; // force extends to Schema\n                }\n\n                currentStructure.name = className;\n\n                const types = callExpression.arguments[0] as any;\n                for (let i = 0; i < types.properties.length; i++) {\n                    const prop = types.properties[i];\n\n                    const property = currentProperty || new Property();\n                    property.name = prop.name.escapedText;\n\n                    currentStructure.addProperty(property);\n                    defineProperty(property, prop.initializer);\n                }\n            }\n\n            break;\n\n        case ts.SyntaxKind.EnumMember:\n            if (currentStructure instanceof Enum) {\n                const initializer = (node as any).initializer?.text;\n                const name = node.getFirstToken().getText();\n                const property = currentProperty || new Property();\n                property.name = name;\n                if (initializer !== undefined) {\n                    property.type = initializer;\n                }\n                currentStructure.addProperty(property);\n                currentProperty = undefined;\n            }\n            break;\n    }\n\n    ts.forEachChild(node, (n: ts.Node) => inspectNode(n, context, decoratorName));\n}\n\nlet parsedFiles: { [filename: string]: boolean };\n\nexport function parseFiles(\n    fileNames: string[],\n    decoratorName: string = \"type\",\n    context: Context = new Context()\n) {\n    /**\n     * Re-set globalContext for each test case\n     */\n    if (globalContext !== context) {\n        parsedFiles = {};\n        globalContext = context;\n    }\n\n    fileNames.forEach((fileName) => {\n        let sourceFile: ts.Node;\n        let sourceFileName: string;\n\n        const fileNameAlternatives = [];\n\n        if (\n            !fileName.endsWith(\".ts\") &&\n            !fileName.endsWith(\".js\") &&\n            !fileName.endsWith(\".mjs\")\n        ) {\n            fileNameAlternatives.push(`${fileName}.ts`);\n            fileNameAlternatives.push(`${fileName}/index.ts`);\n\n        } else if (fileName.endsWith(\".js\")) {\n            // Handle .js extensions by also trying .ts (ESM imports often use .js extension)\n            fileNameAlternatives.push(fileName);\n            fileNameAlternatives.push(fileName.replace(/\\.js$/, \".ts\"));\n\n        } else {\n            fileNameAlternatives.push(fileName);\n        }\n\n        for (let i = 0; i < fileNameAlternatives.length; i++) {\n            try {\n                sourceFileName = path.resolve(fileNameAlternatives[i]);\n\n                if (parsedFiles[sourceFileName]) {\n                    break;\n                }\n\n                sourceFile = ts.createSourceFile(\n                    sourceFileName,\n                    readFileSync(sourceFileName).toString(),\n                    ts.ScriptTarget.Latest,\n                    true\n                );\n\n                parsedFiles[sourceFileName] = true;\n\n                break;\n            } catch (e) {\n                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);\n            }\n        }\n\n        if (sourceFile) {\n            inspectNode(sourceFile, context, decoratorName);\n        }\n    });\n\n    return context.getStructures();\n}\n\n/**\n * TypeScript 4.8+ has introduced a change on how to access decorators.\n * - https://github.com/microsoft/TypeScript/pull/49089\n * - https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees\n */\nexport function getDecorators(node: ts.Node | null | undefined,): undefined | ts.Decorator[] {\n    if (node == undefined) { return undefined; }\n\n    // TypeScript 4.7 and below\n    // @ts-ignore\n    if (node.decorators) { return node.decorators; }\n\n    // TypeScript 4.8 and above\n    // @ts-ignore\n    if (ts.canHaveDecorators && ts.canHaveDecorators(node)) {\n        // @ts-ignore\n        const decorators = ts.getDecorators(node);\n        return decorators ? Array.from(decorators) : undefined;\n    }\n\n    // @ts-ignore\n    return node.modifiers?.filter(ts.isDecorator);\n}\n","import {\n    Class,\n    Property,\n    File,\n    getCommentHeader,\n    Interface,\n    Enum,\n} from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\nimport { Context } from \"../types.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"float\",\n    \"boolean\": \"bool\",\n    \"int8\": \"sbyte\",\n    \"uint8\": \"byte\",\n    \"int16\": \"short\",\n    \"uint16\": \"ushort\",\n    \"int32\": \"int\",\n    \"uint32\": \"uint\",\n    \"int64\": \"long\",\n    \"uint64\": \"ulong\",\n    \"float32\": \"float\",\n    \"float64\": \"double\",\n}\n\n/**\n * C# Code Generator\n */\nconst capitalize = (s: string) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\nexport function generate(context: Context, options: GenerateOptions): File[] {\n    // enrich typeMaps with enums\n    context.enums.forEach((structure) => {\n        typeMaps[structure.name] = structure.name;\n    });\n    return [\n        ...context.classes.map(structure => ({\n            name: `${structure.name}.cs`,\n            content: generateClass(structure, options.namespace)\n        })),\n        ...context.interfaces.map(structure => ({\n            name: `${structure.name}.cs`,\n            content: generateInterface(structure, options.namespace),\n        })),\n        ...context.enums.filter(structure => structure.name !== 'OPERATION').map((structure) => ({\n            name: `${structure.name}.cs`,\n            content: generateEnum(structure, options.namespace),\n        })),\n    ];\n}\n\nfunction generateClass(klass: Class, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n\nusing Colyseus.Schema;\n#if UNITY_5_3_OR_NEWER\nusing UnityEngine.Scripting;\n#endif\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${indent}public partial class ${klass.name} : ${klass.extends} {\n#if UNITY_5_3_OR_NEWER\n[Preserve]\n#endif\npublic ${klass.name}() { }\n${klass.properties.map((prop) => generateProperty(prop, indent)).join(\"\\n\\n\")}\n${indent}}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\nfunction generateEnum(_enum: Enum, namespace: string) {\n    const indent = namespace ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${indent}public struct ${_enum.name} {\n\n${_enum.properties\n    .map((prop) => {\n        let dataType: string = \"int\";\n        let value: any;\n\n        if(prop.type) {\n            if(isNaN(Number(prop.type))) {\n                value = `\"${prop.type}\"`;\n                dataType = \"string\";\n            } else {\n                value = Number(prop.type);\n                dataType = Number.isInteger(value)? 'int': 'float';\n            }\n        } else {\n            value = _enum.properties.indexOf(prop);\n        }\n        return `${indent}\\tpublic const ${dataType} ${prop.name} = ${value};`;\n    })\n        .join(\"\\n\")}\n${indent}}\n${namespace ? \"}\" : \"\"}`\n}\n\nfunction generateProperty(prop: Property, indent: string = \"\") {\n    let typeArgs = `\"${prop.type}\"`;\n    let property = \"public\";\n    let langType: string;\n    let initializer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        langType = getType(prop);\n        typeArgs += `, typeof(${langType})`;\n\n        if (!isUpcaseFirst) {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        initializer = `null`;\n\n    } else {\n        langType = getType(prop);\n        initializer = `default(${langType})`;\n    }\n\n    property += ` ${langType} ${prop.name}`;\n\n    let ret = (prop.deprecated) ? `\\t\\t[System.Obsolete(\"field '${prop.name}' is deprecated.\", true)]\\n` : '';\n\n    return ret + `\\t${indent}[Type(${prop.index}, ${typeArgs})]\n\\t${indent}${property} = ${initializer};`;\n}\n\nfunction generateInterface(struct: Interface, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n\nusing Colyseus.Schema;\n${namespace ? `\\nnamespace ${namespace} {` : \"\"}\n${indent}public class ${struct.name} {\n${struct.properties.map(prop => `\\t${indent}public ${getType(prop)} ${prop.name};`).join(\"\\n\")}\n${indent}}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\nfunction getChildType(prop: Property) {\n    return typeMaps[prop.childType];\n}\n\nfunction getType(prop: Property) {\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n        let type: string;\n\n        if(prop.type === \"ref\") {\n            type = (isUpcaseFirst)\n                ? prop.childType\n                : getChildType(prop);\n        } else {\n            const containerClass = capitalize(prop.type);\n            type = (isUpcaseFirst)\n                ? `${containerClass}Schema<${prop.childType}>`\n                : `${containerClass}Schema<${getChildType(prop)}>`;\n        }\n        return type;\n\n    } else {\n        return (prop.type === \"array\")\n            ? `${typeMaps[prop.childType] || prop.childType}[]`\n            : typeMaps[prop.type];\n    }\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"varint_t\",\n    \"boolean\": \"bool\",\n    \"int8\": \"int8_t\",\n    \"uint8\": \"uint8_t\",\n    \"int16\": \"int16_t\",\n    \"uint16\": \"uint16_t\",\n    \"int32\": \"int32_t\",\n    \"uint32\": \"uint32_t\",\n    \"int64\": \"int64_t\",\n    \"uint64\": \"uint64_t\",\n    \"float32\": \"float32_t\",\n    \"float64\": \"float64_t\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\n/**\n * C++ Code Generator\n */\n\nconst capitalize = (s: string) => {\n    if (typeof s !== 'string') return ''\n    return s.charAt(0).toUpperCase() + s.slice(1);\n}\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hpp\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const propertiesPerType: {[type: string]: Property[]} = {};\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        if (!propertiesPerType[type]) {\n            propertiesPerType[type] = [];\n        }\n\n        propertiesPerType[type].push(property);\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    const allProperties = getAllProperties(klass, allClasses);\n    const createInstanceMethod = (allRefs.length === 0) ? \"\" :\n    `\\tinline Schema* createInstance(std::type_index type) {\n\\t\\t${generateFieldIfElseChain(allRefs,\n    (property) => `type == typeid(${property.childType})`,\n    (property) => `return new ${property.childType}();`,\n    (property) => typeMaps[property.childType] === undefined)}\n\\t\\treturn ${klass.extends}::createInstance(type);\n\\t}`;\n\n    return `${getCommentHeader()}\n#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__\n#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1\n\n#include \"schema.h\"\n#include <typeinfo>\n#include <typeindex>\n\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `#include \"${childType}.hpp\"`).\n    join(\"\\n\")}\n\nusing namespace colyseus::schema;\n\n${namespace ? `namespace ${namespace} {` : \"\"}\nclass ${klass.name} : public ${klass.extends} {\npublic:\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n\n\\t${klass.name}() {\n\\t\\tthis->_indexes = ${generateAllIndexes(allProperties)};\n\\t\\tthis->_types = ${generateAllTypes(allProperties)};\n\\t\\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};\n\\t\\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};\n\\t}\n\n\\tvirtual ~${klass.name}() {\n\\t\\t${generateDestructors(allProperties).join(\"\\n\\t\\t\")}\n\\t}\n\nprotected:\n${Object.keys(propertiesPerType).map(type =>\n    generateGettersAndSetters(klass, type, propertiesPerType[type])).\n    join(\"\\n\")}\n\n${createInstanceMethod}\n};\n${namespace ? \"}\" : \"\"}\n\n#endif\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let property = \"\";\n    let langType: string;\n    let initializer = \"\";\n    let isPropPointer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}*>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}*>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n        isPropPointer = \"*\";\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${isPropPointer}${prop.name}`;\n\n    return `\\t${property} = ${initializer};`\n}\n\nfunction generateGettersAndSetters(klass: Class, type: string, properties: Property[]) {\n    let langType = typeMaps[type];\n    let typeCast = \"\";\n\n    const getMethodName = `get${capitalize(type)}`;\n    const setMethodName = `set${capitalize(type)}`;\n\n    if (type === \"ref\") {\n        langType = \"Schema*\";\n\n    } else if (type === \"array\") {\n        langType = `ArraySchema<char*> *`;\n        typeCast = `(ArraySchema<char*> *)`;\n\n    } else if (type === \"map\") {\n        langType = `MapSchema<char*> *`;\n        typeCast = `(MapSchema<char*> *)`;\n    }\n\n    return `\\tinline ${langType} ${getMethodName}(const string &field)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => `return ${typeCast}this->${property.name};`)}\n\\t\\treturn ${klass.extends}::${getMethodName}(field);\n\\t}\n\n\\tinline void ${setMethodName}(const string &field, ${langType} value)\n\\t{\n\\t\\t${generateFieldIfElseChain(properties,\n    (property) => `field == \"${property.name}\"`,\n    (property) => {\n        const isSchemaType = (typeMaps[property.childType] === undefined)\n\n        if (type === \"ref\") {\n            langType = `${property.childType}*`;\n            typeCast = (isSchemaType)\n                ? `(${property.childType}*)`\n                : `/* bug? */`;\n\n        } else if (type === \"array\") {\n            typeCast = (isSchemaType)\n                ? `(ArraySchema<${property.childType}*> *)`\n                : `(ArraySchema<${typeMaps[property.childType]}> *)`;\n\n        } else if (type === \"map\") {\n            typeCast = (isSchemaType)\n                ? `(MapSchema<${property.childType}*> *)`\n                : `(MapSchema<${typeMaps[property.childType]}> *)`;\n        }\n\n        return `this->${property.name} = ${typeCast}value;\\n\\t\\t\\treturn;`\n    })}\n\\t\\treturn ${klass.extends}::${setMethodName}(field, value);\n\\t}`;\n}\n\nfunction generateFieldIfElseChain(\n    properties: Property[],\n    ifCallback: (property: Property) => string,\n    callback: (property: Property) => string,\n    filter: (property: Property) => boolean = (_) => true,\n) {\n    let chain = \"\";\n\n    const uniqueChecks: string[] = [];\n    properties.filter(filter).forEach((property, i) => {\n        const check = ifCallback(property);\n        if (uniqueChecks.indexOf(check) === -1) {\n            uniqueChecks.push(check);\n\n        } else {\n            return;\n        }\n\n        if (i === 0) { chain += \"if \" } else { chain += \" else if \" }\n        chain += `(${check})\n\\t\\t{\n\\t\\t\\t${callback(property)}\\n\n\\t\\t}`\n    });\n\n    return chain;\n}\n\nfunction generateAllIndexes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.name}\"}`).join(\", \")}}`\n\n}\n\nfunction generateAllTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => `{${i}, \"${property.type}\"}`).join(\", \")}}`\n}\n\nfunction generateAllChildSchemaTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (property.childType && typeMaps[property.childType] === undefined) {\n            return `{${i}, typeid(${property.childType})}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateAllChildPrimitiveTypes(properties: Property[]) {\n    return `{${properties.map((property, i) => {\n        if (typeMaps[property.childType] !== undefined) {\n            return `{${i}, \"${property.childType}\"}`\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null).join(\", \")}}`\n}\n\nfunction generateDestructors(properties: Property[]) {\n    return properties.map((property, i) => {\n        if (property.childType) {\n            return `delete this->${property.name};`;\n        } else {\n            return null;\n        }\n    }).filter(r => r !== null);\n}\n\nfunction getAllProperties (klass: Class, allClasses: Class[]) {\n    let properties: Property[] = [];\n\n    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {\n        properties = properties.concat(klass.properties);\n    });\n\n    return properties;\n}","import { Class, Property, File, getCommentHeader, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"String\",\n    \"number\": \"Dynamic\",\n    \"boolean\": \"Bool\",\n    \"int8\": \"Int\",\n    \"uint8\": \"UInt\",\n    \"int16\": \"Int\",\n    \"uint16\": \"UInt\",\n    \"int32\": \"Int\",\n    \"uint32\": \"UInt\",\n    \"int64\": \"Int\",\n    \"uint64\": \"UInt\",\n    \"float32\": \"Float\",\n    \"float64\": \"Float\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".hx\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction getInheritanceTree(klass: Class, allClasses: Class[], includeSelf: boolean = true) {\n    let currentClass = klass;\n    let inheritanceTree: Class[] = [];\n\n    if (includeSelf) {\n        inheritanceTree.push(currentClass);\n    }\n\n    while (currentClass.extends !== \"Schema\") {\n        currentClass = allClasses.find(klass => klass.name == currentClass.extends);\n        inheritanceTree.push(currentClass);\n    }\n\n    return inheritanceTree;\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    return `${getCommentHeader()}\n\n${namespace ? `package ${namespace};` : \"\"}\nimport io.colyseus.serializer.schema.Schema;\nimport io.colyseus.serializer.schema.types.*;\n\nclass ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => generateProperty(prop)).join(\"\\n\")}\n}\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let langType: string;\n    let initializer = \"\";\n    let typeArgs = `\"${prop.type}\"`;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    // TODO: remove initializer. The callbacks at the Haxe decoder side have a\n    // \"FIXME\" comment about this on Decoder.hx\n\n    return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType} = ${initializer};\\n`\n    // return `\\t@:type(${typeArgs})\\n\\tpublic var ${prop.name}: ${langType};\\n`\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context, Interface } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return [\n        ...context.classes.map(structure => ({\n            name: structure.name + \".ts\",\n            content: generateClass(structure, options.namespace, context.classes)\n        })),\n        ...context.interfaces.map(structure => ({\n            name: structure.name + \".ts\",\n            content: generateInterface(structure, options.namespace, context.classes),\n        }))\n    ];\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\" || type === \"set\")) {\n            allRefs.push(property);\n        }\n    });\n\n    return `${getCommentHeader()}\n\nimport { Schema, type, ArraySchema, MapSchema, SetSchema, DataChange } from '@colyseus/schema';\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `import { ${childType} } from './${childType}'`).\n    join(\"\\n\")}\n\nexport class ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => `    ${generateProperty(prop)}`).join(\"\\n\")}\n}\n`;\n}\n\nfunction generateProperty(prop: Property) {\n    let langType: string;\n    let initializer = \"\";\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = `${prop.childType}`;\n            initializer = `new ${prop.childType}()`;\n            typeArgs = `${prop.childType}`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `[ ${prop.childType} ]`\n                : `[ \"${prop.childType}\" ]`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `{ map: ${prop.childType} }`\n                : `{ map: \"${prop.childType}\" }`;\n        } else if (prop.type === \"set\") {\n            langType = (isUpcaseFirst)\n                ? `SetSchema<${prop.childType}>`\n                : `SetSchema<${typeMaps[prop.childType]}>`;\n            initializer = `new ${langType}()`;\n            typeArgs = (isUpcaseFirst)\n                ? `{ set: ${prop.childType} }`\n                : `{ set: \"${prop.childType}\" }`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    // TS1263: \"Declarations with initializers cannot also have definite assignment assertions\"\n    const definiteAssertion = initializer ? \"\" : \"!\";\n\n    return `@type(${typeArgs}) public ${prop.name}${definiteAssertion}: ${langType}${(initializer) ? ` = ${initializer}` : \"\"};`\n}\n\n\nfunction generateInterface(structure: Interface, namespace: string, allClasses: Class[]) {\n    return `${getCommentHeader()}\n\nexport interface ${structure.name} {\n${structure.properties.map(prop => `    ${prop.name}: ${prop.type};`).join(\"\\n\")}\n}\n`;\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".js\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    return `${getCommentHeader()}\n\nconst schema = require(\"@colyseus/schema\");\nconst Schema = schema.Schema;\nconst type = schema.type;\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `const ${childType} = require(\"./${childType}\");`).\n    join(\"\\n\")}\n\nclass ${klass.name} extends ${klass.extends} {\n    constructor () {\n        super();\n${klass.properties.\n    filter(prop => prop.childType !== undefined).\n    map(prop => \"        \" + generatePropertyInitializer(prop)).join(\"\\n\")}\n    }\n}\n${klass.properties.map(prop => generatePropertyDeclaration(klass.name, prop)).join(\"\\n\")}\n\nexport default ${klass.name};\n`;\n}\n\nfunction generatePropertyDeclaration(className: string, prop: Property) {\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `, ${prop.childType}`;\n\n        } else {\n            typeArgs += `, \"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            typeArgs = `${prop.childType}`;\n\n        } else if(prop.type === \"array\") {\n            typeArgs = (isUpcaseFirst)\n                ? `[ ${prop.childType} ]`\n                : `[ \"${prop.childType}\" ]`;\n\n        } else if(prop.type === \"map\") {\n            typeArgs = (isUpcaseFirst)\n                ? `{ map: ${prop.childType} }`\n                : `{ map: \"${prop.childType}\" }`;\n        }\n\n    } else {\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    return `type(${typeArgs})(${className}.prototype, \"${prop.name}\");`;\n}\n\nfunction generatePropertyInitializer(prop: Property) {\n    let initializer = \"\";\n\n    if(prop.type === \"ref\") {\n        initializer = `new ${prop.childType}()`;\n\n    } else if(prop.type === \"array\") {\n        initializer = `new schema.ArraySchema()`;\n\n    } else if(prop.type === \"map\") {\n        initializer = `new schema.MapSchema()`;\n    }\n\n    return `this.${prop.name} = ${initializer}`;\n}\n","import { Class, Property, File, getCommentHeader, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"String\",\n    \"number\": \"float\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"byte\",\n    \"uint8\": \"short\",\n    \"int16\": \"short\",\n    \"uint16\": \"int\",\n    \"int32\": \"int\",\n    \"uint32\": \"long\",\n    \"int64\": \"long\",\n    \"uint64\": \"long\",\n    \"float32\": \"float\",\n    \"float64\": \"double\",\n}\n\nconst typeInitializer: { [key: string]: string } = {\n    \"string\": '\"\"',\n    \"number\": \"0\",\n    \"boolean\": \"false\",\n    \"int8\": \"0\",\n    \"uint8\": \"0\",\n    \"int16\": \"0\",\n    \"uint16\": \"0\",\n    \"int32\": \"0\",\n    \"uint32\": \"0\",\n    \"int64\": \"0\",\n    \"uint64\": \"0\",\n    \"float32\": \"0\",\n    \"float64\": \"0\",\n}\n\n/**\n * C# Code Generator\n */\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".java\",\n        content: generateClass(klass, options.namespace)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string) {\n    const indent = (namespace) ? \"\\t\" : \"\";\n    return `${getCommentHeader()}\n${namespace ? `\\npackage ${namespace};` : \"\"}\n\nimport io.colyseus.serializer.schema.Schema;\nimport io.colyseus.serializer.schema.annotations.SchemaClass;\nimport io.colyseus.serializer.schema.annotations.SchemaField;\n\n@SchemaClass\n${indent}public class ${klass.name} extends ${klass.extends} {\n${klass.properties.map(prop => generateProperty(prop, indent)).join(\"\\n\\n\")}\n${indent}}\n${namespace ? \"}\" : \"\"}\n`;\n}\n\nfunction generateProperty(prop: Property, indent: string = \"\") {\n    let typeArgs = `${prop.index}/${prop.type}`;\n    let property = \"public\";\n    let langType: string;\n    let ctorArgs: string = \"\";\n    let initializer = \"\";\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (prop.type !== \"ref\" && isUpcaseFirst) {\n            ctorArgs = `${prop.childType}.class`;\n        }\n\n        if(prop.type === \"ref\") {\n            langType = (isUpcaseFirst)\n                ? prop.childType\n                : typeMaps[prop.childType];\n\n            initializer = `new ${langType}${(prop.type !== \"ref\" && isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n\n        } else if(prop.type === \"array\") {\n            langType = (isUpcaseFirst)\n                ? `ArraySchema<${prop.childType}>`\n                : `ArraySchema`;\n\n            initializer = `new ArraySchema${(isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n\n        } else if(prop.type === \"map\") {\n            langType = (isUpcaseFirst)\n                ? `MapSchema<${prop.childType}>`\n                : `MapSchema`;\n\n            initializer = `new MapSchema${(isUpcaseFirst) ? \"<>\" : \"\"}(${ctorArgs})`;\n        }\n\n        if (prop.type !== \"ref\") {\n            typeArgs += (isUpcaseFirst)\n                ? `/ref`\n                : `/${prop.childType}`;\n        }\n\n    } else {\n        langType = typeMaps[prop.type];\n        initializer = typeInitializer[prop.type];\n    }\n\n    property += ` ${langType} ${prop.name}`;\n\n    return `\\t@SchemaField(\"${typeArgs}\")\\t${indent}\n\\t${indent}${property} = ${initializer};`\n}\n","import { Class, Property, File, getCommentHeader, getInheritanceTree, Context } from \"../types.js\";\nimport { GenerateOptions } from \"../api.js\";\n\n/**\n    TODO:\n    - Support inheritance\n    - Support importing Schema dependencies\n*/\n\nconst typeMaps: { [key: string]: string } = {\n    \"string\": \"string\",\n    \"number\": \"number\",\n    \"boolean\": \"boolean\",\n    \"int8\": \"number\",\n    \"uint8\": \"number\",\n    \"int16\": \"number\",\n    \"uint16\": \"number\",\n    \"int32\": \"number\",\n    \"uint32\": \"number\",\n    \"int64\": \"number\",\n    \"uint64\": \"number\",\n    \"float32\": \"number\",\n    \"float64\": \"number\",\n}\n\nconst distinct = (value: string, index: number, self: string[]) =>\n    self.indexOf(value) === index;\n\nexport function generate (context: Context, options: GenerateOptions): File[] {\n    return context.classes.map(klass => ({\n        name: klass.name + \".lua\",\n        content: generateClass(klass, options.namespace, context.classes)\n    }));\n}\n\nfunction generateClass(klass: Class, namespace: string, allClasses: Class[]) {\n    const allRefs: Property[] = [];\n    klass.properties.forEach(property => {\n        let type = property.type;\n\n        // keep all refs list\n        if ((type === \"ref\" || type === \"array\" || type === \"map\")) {\n            allRefs.push(property);\n        }\n    });\n\n    // Inheritance support\n    const inherits = (klass.extends !== \"Schema\")\n        ? `, ${klass.extends}`\n        : \"\";\n\n    return `${getCommentHeader().replace(/\\/\\//mg, \"--\")}\n\nlocal schema = require 'colyseus.serializer.schema.schema'\n${allRefs.\n    filter(ref => ref.childType && typeMaps[ref.childType] === undefined).\n    map(ref => ref.childType).\n    concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).\n    filter(distinct).\n    map(childType => `local ${childType} = require '${(namespace ? `${namespace}.` : '')}${childType}'`).\n    join(\"\\n\")}\n\n---@class ${klass.name}: ${klass.extends}\n${klass.properties.map(prop => `---@field ${prop.name} ${getLUATypeAnnotation(prop)}`).join(\"\\n\")}\nlocal ${klass.name} = schema.define({\n${klass.properties.map(prop => generatePropertyDeclaration(prop)).join(\",\\n\")},\n    [\"_fields_by_index\"] = { ${klass.properties.map(prop => `\"${prop.name}\"`).join(\", \")} },\n}${inherits})\n\nreturn ${klass.name}\n`;\n}\n\nfunction generatePropertyDeclaration(prop: Property) {\n    let typeArgs: string;\n\n    if (prop.childType) {\n        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);\n\n        if (isUpcaseFirst) {\n            typeArgs += `${prop.childType}`;\n\n        } else {\n            typeArgs += `\"${prop.childType}\"`;\n        }\n\n        if(prop.type === \"ref\") {\n            typeArgs = (isUpcaseFirst)\n                ? `${prop.childType}`\n                : `\"${prop.childType}\"`;\n\n        } else {\n            typeArgs = (isUpcaseFirst)\n                ? `{ ${prop.type} = ${prop.childType} }`\n                : `{ ${prop.type} = \"${prop.childType}\" }`;\n        }\n\n    } else {\n        typeArgs = `\"${prop.type}\"`;\n    }\n\n    return `    [\"${prop.name}\"] = ${typeArgs}`;\n}\n\nfunction getLUATypeAnnotation(prop: Property) {\n    if (prop.type === \"ref\") {\n        return prop.childType;\n\n    } else if (prop.type === \"array\") {\n        return \"ArraySchema\";\n\n    } else if (prop.type === \"map\") {\n        return \"MapSchema\";\n\n    } else {\n        return typeMaps[prop.type];\n    }\n}","import * as fs from \"fs\";\nimport * as path from \"path\";\n\nimport { File } from \"./types.js\";\nimport { parseFiles } from \"./parser.js\";\n\n// Statically import all language generators (for bundling)\nimport { generate as csharp } from \"./languages/csharp.js\";\nimport { generate as cpp } from \"./languages/cpp.js\";\nimport { generate as haxe } from \"./languages/haxe.js\";\nimport { generate as ts } from \"./languages/ts.js\";\nimport { generate as js } from \"./languages/js.js\";\nimport { generate as java } from \"./languages/java.js\";\nimport { generate as lua } from \"./languages/lua.js\";\n\nconst generators: Record<string, Function> = { csharp, cpp, haxe, ts, js, java, lua, };\n\nexport interface GenerateOptions {\n    files: string[],\n    output: string;\n    decorator?: string;\n    namespace?: string;\n}\n\nexport function generate(targetId: string, options: GenerateOptions) {\n    const generator = generators[targetId];\n\n    if (!generator) {\n        throw new Error(\"You must provide a valid generator as argument, such as: --csharp, --haxe or --cpp\");\n    }\n\n    if (!fs.existsSync(options.output)) {\n        console.log(\"Creating\", options.output, \"directory\");\n        fs.mkdirSync(options.output);\n    }\n\n    /**\n     * Default `@type()` decorator name\n     */\n    if (!options.decorator) { options.decorator = \"type\"; }\n\n    // resolve wildcard files\n    options.files = options.files.reduce((acc, cur) => {\n        if (cur.endsWith(\"*\")) {\n            acc.push(...recursiveFiles(cur.slice(0, -1)).filter(filename => /\\.(js|ts|mjs)$/.test(filename)));\n        } else {\n            acc.push(cur)\n        }\n        return acc;\n    }, [])\n\n    const structures = parseFiles(options.files, options.decorator);\n\n    // Post-process classes before generating\n    structures.classes.forEach(klass => klass.postProcessing());\n\n    const files = generator(structures, options);\n\n    files.forEach((file: File) => {\n        const outputPath = path.resolve(options.output, file.name);\n        fs.writeFileSync(outputPath, file.content);\n        console.log(\"generated:\", file.name);\n    });\n}\n\nfunction recursiveFiles(dir: string): string[] {\n    const files = fs.readdirSync(dir, { withFileTypes: true });\n    let collect: string[] = [];\n    files.forEach(file => {\n        const filename = path.resolve(dir, file.name);\n        file.isDirectory() ? collect.push(...recursiveFiles(filename)) : collect.push(filename);\n    })\n    return collect;\n}\n","import argv from \"./argv.js\";\nimport { generate } from \"./api.js\";\n\nconst supportedTargets: Record<string, string> = {\n    csharp: 'generate for C#/Unity',\n    cpp: 'generate for C++',\n    haxe: 'generate for Haxe',\n    ts: 'generate for TypeScript',\n    js: 'generate for JavaScript',\n    java: 'generate for Java',\n    lua: 'generate for LUA',\n}\n\nfunction displayHelp() {\n    console.log(`\\nschema-codegen [path/to/Schema.ts]\n\nUsage (C#/Unity)\n    schema-codegen src/Schema.ts --output client-side/ --csharp --namespace MyGame.Schema\n\nValid options:\n    --output: the output directory for generated client-side schema files\n${Object.\n    keys(supportedTargets).\n    map((targetId) => (\n`    --${targetId}: ${supportedTargets[targetId]}`\n    )).\n    join(\"\\n\")}\n\nOptional:\n    --namespace: generate namespace on output code\n    --decorator: custom name for @type decorator to scan for`);\n    process.exit();\n}\n\nconst args = argv(process.argv.slice(2));\nif (args.help) {\n    displayHelp();\n}\n\nlet targetId: string;\nfor (let target in supportedTargets) {\n    if (args[target]) {\n        targetId = target;\n    }\n}\n\nif (!args.output) {\n    console.error(\"You must provide a valid --output directory.\");\n    displayHelp();\n}\n\ntry {\n    args.files = args._;\n    generate(targetId, {\n        files: args._,\n        decorator: args.decorator,\n        output: args.output,\n        namespace: args.namespace\n    });\n\n} catch (e) {\n    console.error(e.message);\n    console.error(e.stack);\n    displayHelp();\n}\n"],"names":["path","fs","ts","readFileSync","typeMaps","capitalize","generate","generateClass","generateInterface","generateProperty","typeInitializer","distinct","generatePropertyDeclaration","csharp","cpp","haxe","js","java","lua"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAGG;AACH,WAAe,CAAC,KAAe,KAAS;IACvC,IAAI,KAAK,GAAQ,EAAE;IACnB,IAAI,KAAK,GAAQ,EAAE;AAEnB,IAAA,MAAM,mBAAmB,GAAG,CAAC,KAAU,MAAM,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM,GAAG,IAAI,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,WAAW,EAAE,KAAK,OAAO,GAAG,KAAK,GAAG,KAAK,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC;AAC9L,IAAA,MAAM,kBAAkB,GAAG,CAAC,KAAa,KAAK,KAAK,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;AAExE,IAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,MAAM,WAAW,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC;QACzC,MAAM,aAAa,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,EAAE,IAAI,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG;AACnJ,QAAA,MAAM,OAAO,GAAG,WAAW,KAAK,EAAE,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC;AAEtH,QAAA,IAAI,WAAW,KAAK,EAAE,EAAE;AACvB,YAAA,KAAK,CAAC,OAAO,CAAC,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;QACtE;aACK,IAAI,aAAa,EAAE;AACvB,YAAA,KAAK,CAAC,OAAO,CAAC,GAAG,mBAAmB,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;AAClD,YAAA,CAAC,EAAE;QACJ;AAAO,aAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AACtC,YAAA,IAAI,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;AAC/B,gBAAA,KAAK,CAAC,OAAO,CAAC,GAAG,IAAI;YACtB;iBACK;AACJ,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBACxC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI;gBAChC;YACD;QACD;aAAO;YACN,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,OAAO,CAAC,CAAC;QACzC;IACD;AAEA,IAAA,OAAO,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE;AAC3B,QAAA,GAAG,EAAE;AACL,KAAA,CAAC;AACH,CAAC;;ACpCD,IAAI,QAAO,SAAS,CAAC,KAAK,WAAW,EAAE;AACnC,IAAA,MAAM,CAAC,SAAS,GAAGA,eAAI,CAAC,OAAO,CAAC,IAAI,GAAG,CAAC,yPAAe,CAAC,CAAC,QAAQ,CAAC;AACtE;AAEA,MAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAACC,aAAE,CAAC,YAAY,CAAC,SAAS,GAAG,qBAAqB,CAAC,CAAC,QAAQ,EAAE,CAAC,CAAC,OAAO;AACjG,MAAM,cAAc,GAAG;;;;mCAIY,OAAO;CACzC;AAEK,SAAU,gBAAgB,CAAC,iBAAA,GAA4B,IAAI,EAAA;IAC7D,OAAO,CAAA,EAAG,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,CAAA,EAAG,iBAAiB,CAAA,CAAA,EAAI,IAAI,CAAA,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAE;AACjG;MAEa,OAAO,CAAA;IAChB,OAAO,GAAY,EAAE;IACrB,UAAU,GAAgB,EAAE;IAC5B,KAAK,GAAW,EAAE;IAElB,aAAa,GAAA;QACT,OAAO;YACH,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,IAAG;AACjC,gBAAA,IAAI,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,EAAE;AAC3B,oBAAA,OAAO,IAAI;gBAEf;qBAAO;oBACH,IAAI,WAAW,GAAG,KAAK;oBACvB,OAAO,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,EAAE;AACnD,wBAAA,IAAI,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,EAAE;AACjC,4BAAA,OAAO,IAAI;wBACf;oBACJ;gBACJ;AACA,gBAAA,OAAO,KAAK;AAChB,YAAA,CAAC,CAAC;YACF,UAAU,EAAE,IAAI,CAAC,UAAU;YAC3B,KAAK,EAAE,IAAI,CAAC,KAAK;SACpB;IACL;AAEA,IAAA,YAAY,CAAC,SAAqB,EAAA;AAC9B,QAAA,IAAI,SAAS,CAAC,OAAO,KAAK,IAAI,EAAE;YAAE;AAAQ,QAAA,CAAC;AAC3C,QAAA,SAAS,CAAC,OAAO,GAAG,IAAI;AAExB,QAAA,IAAI,SAAS,YAAY,KAAK,EAAE;AAC5B,YAAA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC;QAChC;AAAO,aAAA,IAAI,SAAS,YAAY,SAAS,EAAE;AACvC,YAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC;QACnC;AAAO,aAAA,IAAI,SAAS,YAAY,IAAI,EAAE;AAClC,YAAA,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC;QAC9B;IACJ;AAEQ,IAAA,cAAc,CAAC,KAAY,EAAA;AAC/B,QAAA,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,KAAK,CAAC,OAAO,CAAC;IAC3D;AAEQ,IAAA,aAAa,CAAC,KAAY,EAAA;QAC9B,IAAI,QAAQ,GAAY,KAAK;QAE7B,IAAI,YAAY,GAAG,KAAK;AACxB,QAAA,OAAO,CAAC,QAAQ,IAAI,YAAY,EAAE;;;;;AAK9B,YAAA,QAAQ,IACJ,YAAY,CAAC,OAAO,KAAK,QAAQ;gBACjC,YAAY,CAAC,OAAO,KAAK,eAAe;AACxC,gBAAA,YAAY,CAAC,OAAO,KAAK,eAAe,CAC3C;;;;;AAMD,YAAA,IAAI,YAAY,KAAK,KAAK,IAAI,QAAQ,EAAE;AACpC,gBAAA,KAAK,CAAC,OAAO,GAAG,QAAQ;YAC5B;AAEA,YAAA,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC;QACpD;AAEA,QAAA,OAAO,QAAQ;IACnB;AACH;MASY,SAAS,CAAA;AAClB,IAAA,OAAO;AACP,IAAA,IAAI;IACJ,UAAU,GAAe,EAAE;AAE3B,IAAA,WAAW,CAAC,QAAkB,EAAA;QAC1B,IAAI,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;;AAElC,YAAA,QAAQ,CAAC,SAAS,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AACxD,YAAA,QAAQ,CAAC,IAAI,GAAG,OAAO;AACvB,YAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC;QAElC;aAAO;AACH,YAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC;QAClC;IACJ;AACH;MAEY,KAAK,CAAA;AACd,IAAA,OAAO;AACP,IAAA,IAAI;IACJ,UAAU,GAAe,EAAE;AAC3B,IAAA,OAAO;AAEP,IAAA,WAAW,CAAC,QAAkB,EAAA;QAC1B,QAAQ,CAAC,KAAK,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM;AACvC,QAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC;IAClC;IAEA,cAAc,GAAA;AACV;;AAEG;QACH,IAAI,WAAW,GAAU,IAAI;AAE7B,QAAA,OACI,WAAW;aACV,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,WAAW,CAAC,OAAO,CAAC,CAAC,EAChF;AACE,YAAA,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,IAAG;gBAC3B,IAAI,CAAC,KAAK,IAAI,WAAW,CAAC,UAAU,CAAC,MAAM;AAC/C,YAAA,CAAC,CAAC;QACN;IACJ;AACH;MAEY,IAAI,CAAA;AACb,IAAA,OAAO;AACP,IAAA,IAAI;IACJ,UAAU,GAAe,EAAE;AAE3B,IAAA,WAAW,CAAC,QAAkB,EAAA;AAC1B,QAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC;IAClC;AACH;MAEY,QAAQ,CAAA;AACjB,IAAA,KAAK;AACL,IAAA,IAAI;AACJ,IAAA,IAAI;AACJ,IAAA,SAAS;AACT,IAAA,UAAU;AACb;AAOK,SAAU,kBAAkB,CAAC,KAAY,EAAE,UAAmB,EAAE,cAAuB,IAAI,EAAA;IAC7F,IAAI,YAAY,GAAG,KAAK;IACxB,IAAI,eAAe,GAAY,EAAE;IAEjC,IAAI,WAAW,EAAE;AACb,QAAA,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC;IACtC;AAEA,IAAA,OAAO,YAAY,CAAC,OAAO,KAAK,QAAQ,EAAE;AACtC,QAAA,YAAY,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,IAAI,YAAY,CAAC,OAAO,CAAC;AAC3E,QAAA,eAAe,CAAC,IAAI,CAAC,YAAY,CAAC;IACtC;AAEA,IAAA,OAAO,eAAe;AAC1B;;ACjLA,IAAI,gBAA4B;AAChC,IAAI,eAAyB;AAE7B,IAAI,aAAsB;AAE1B,SAAS,cAAc,CAAC,QAAkB,EAAE,WAAgB,EAAA;AACxD,IAAA,IAAIC,aAAE,CAAC,YAAY,CAAC,WAAW,CAAC,EAAE;AAC9B,QAAA,QAAQ,CAAC,IAAI,GAAG,KAAK;AACrB,QAAA,QAAQ,CAAC,SAAS,GAAG,WAAW,CAAC,IAAI;IAEzC;SAAO,IAAI,WAAW,CAAC,IAAI,IAAIA,aAAE,CAAC,UAAU,CAAC,uBAAuB,EAAE;AAClE,QAAA,QAAQ,CAAC,IAAI,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI;AACnD,QAAA,QAAQ,CAAC,SAAS,GAAG,WAAW,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI;IAEnE;SAAO,IAAI,WAAW,CAAC,IAAI,IAAIA,aAAE,CAAC,UAAU,CAAC,sBAAsB,EAAE;AACjE,QAAA,QAAQ,CAAC,IAAI,GAAG,OAAO;QACvB,QAAQ,CAAC,SAAS,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI;IAErD;SAAO;AACH,QAAA,QAAQ,CAAC,IAAI,GAAG,WAAW,CAAC,IAAI;IACpC;AACJ;AAEA,SAAS,WAAW,CAAC,IAAa,EAAE,OAAgB,EAAE,aAAqB,EAAA;AACvE,IAAA,QAAQ,IAAI,CAAC,IAAI;AACb,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,YAAY;AAC3B,YAAA,MAAM,SAAS,GAAI,IAAI,CAAC,MAAc,CAAC,eAAe;YACtD,IAAI,SAAS,IAAK,SAAS,CAAC,IAAe,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE;AACzD,gBAAA,MAAM,UAAU,GAAGF,eAAI,CAAC,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,CAAC;AAC9D,gBAAA,MAAM,YAAY,GAAGA,eAAI,CAAC,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,IAAI,CAAC;gBAC7D,UAAU,CAAC,CAAC,YAAY,CAAC,EAAE,aAAa,EAAE,aAAa,CAAC;YAC5D;YACA;AAEJ,QAAA,KAAKE,aAAE,CAAC,UAAU,CAAC,gBAAgB;AAC/B,YAAA,gBAAgB,GAAG,IAAI,KAAK,EAAE;AAE9B,YAAA,MAAM,eAAe,GAAI,IAAoC,CAAC,eAAe;YAC7E,IAAI,eAAe,IAAI,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;AAC9C,gBAAA,gBAA0B,CAAC,OAAO,GAAG,eAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,EAAE;YAC1F;AAEA,YAAA,OAAO,CAAC,YAAY,CAAC,gBAAgB,CAAC;YACtC;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,oBAAoB;;;;;YAKnC,MAAM,aAAa,GAAI,IAAoC,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;YACvF,IAAI,aAAa,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE;AACzC,gBAAA,gBAAgB,GAAG,IAAI,SAAS,EAAE;AAClC,gBAAA,gBAAgB,CAAC,IAAI,GAAG,aAAa;AAErC,gBAAA,OAAO,CAAC,YAAY,CAAC,gBAAgB,CAAC;YAC1C;YACA;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,eAAe;YAC9B,MAAM,QAAQ,GACV,IACH,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;AAC7B,YAAA,gBAAgB,GAAG,IAAI,IAAI,EAAE;AAC7B,YAAA,gBAAgB,CAAC,IAAI,GAAG,QAAQ;AAChC,YAAA,OAAO,CAAC,YAAY,CAAC,gBAAgB,CAAC;YACtC;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc;;YAE7B;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,iBAAiB;AAChC,YAAA,IAAI,gBAAgB,YAAY,SAAS,EAAE;AACvC,gBAAA,MAAM,oBAAoB,GAAG,IAAI,CAAC,MAAM;AAExC,gBAAA,IACI,gBAAgB,CAAC,IAAI,KAAM,oBAAoD,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,EAC7G;;oBAEE;gBACJ;;AAGA,gBAAA,MAAM,QAAQ,GAAG,IAAI,QAAQ,EAAE;gBAC/B,QAAQ,CAAC,IAAI,GAAI,IAAY,CAAC,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE;gBACzD,QAAQ,CAAC,IAAI,GAAI,IAAY,CAAC,IAAI,CAAC,OAAO,EAAE;AAC5C,gBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;YAC1C;YACA;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,UAAU;AACzB,YAAA,IACI,IAAI,CAAC,OAAO,EAAE,KAAK,YAAY;gBAC/B,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,eAAe,EACpD;AACE,gBAAA,eAAe,GAAG,IAAI,QAAQ,EAAE;AAChC,gBAAA,eAAe,CAAC,UAAU,GAAG,IAAI;gBACjC;YACJ;AAEA,YAAA,IAAI,IAAI,CAAC,OAAO,EAAE,KAAK,aAAa,EAAE;gBAClC,MAAM,IAAI,GAAQ,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM;AAC7C,gBAAA,MAAM,aAAa,GAAG,aAAa,CAAC,IAAI,CAAC;AACzC,gBAAA,MAAM,aAAa,GAAG,IAAI,EAAE,UAAU,EAAE,SAAS;gBACjD,MAAM,YAAY,IAAI,aAAa,EAAE,MAAM,GAAG,CAAC,CAAC;AAEhD;;AAEG;AACH,gBAAA,IAAI,CAAC,YAAY,IAAI,CAAC,aAAa,EAAE;oBACjC;gBACJ;;gBAGA,IAAI,aAAa,EAAE;AACf;;AAEG;oBACH,MAAM,aAAa,GAAQ,aAAa,CAAC,IAAI,EAAE,SAAS,IAAG;wBACvD,OAAQ,SAAS,CAAC,UAAkB,CAAC,UAAU,CAAC,WAAW,KAAK,aAAa;AACjF,oBAAA,CAAC,EAAE,CAAC,UAAU;AAEd,oBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;oBAClD,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW;AACrC,oBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;oBAEtC,MAAM,YAAY,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC;AAC/C,oBAAA,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC;gBAE1C;qBAAO,IACH,IAAI,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC;oBAC9B,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,CAAC,EAC3C;AACE;;AAEG;AACH,oBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;AAClD,oBAAA,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI;AACjD,oBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;AAEtC,oBAAA,MAAM,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAC;AAC5D,oBAAA,cAAc,CAAC,QAAQ,EAAE,YAAY,CAAC;gBAC1C;YAEJ;AAAO,iBAAA,IACH,IAAI,CAAC,OAAO,EAAE,KAAK,WAAW;iBAE1B,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc;AACjD,oBAAA,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,wBAAwB,CAC9D,EACH;AACE;;AAEG;AACH,gBAAA,MAAM,cAAc,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,wBAAwB;AAC/E,sBAAE,IAAI,CAAC,MAAM,CAAC;AACd,sBAAE,IAAI,CAAC,MAA2B;AAEtC;;;AAGG;AACH,gBAAA,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;AACvC,gBAAA,MAAM,QAAQ,GAAG,UAAU,CAAC,WAAW,EAAE;AACzC,gBAAA,MAAM,SAAS,GAAG,cAAc,CAAC,YAAY,EAAE;gBAC/C,MAAM,cAAc,GAAG,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,SAAS,CAAC;AACvD,gBAAA,IAAI,cAAc,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;oBAC5C;gBACJ;gBAEA,IAAI,cAAc,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc,EAAE;oBACtD;gBACJ;gBAEA,MAAM,aAAa,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC;AACjD,gBAAA,MAAM,SAAS,GAAGA,aAAE,CAAC,iBAAiB,CAAC,aAAa;sBAC9C,aAAa,CAAC,IAAI,EAAE,WAAW,CAAC,QAAQ;AAC1C,sBAAE,aAAa,CAAC,OAAO,EAAE;;gBAG7B,IAAI,CAAC,SAAS,EAAE;oBAAE;gBAAO;AAEzB,gBAAA,IAAI,gBAAgB,EAAE,IAAI,KAAK,SAAS,EAAE;AACtC,oBAAA,gBAAgB,GAAG,IAAI,KAAK,EAAE;gBAClC;AACA,gBAAA,OAAO,CAAC,YAAY,CAAC,gBAAgB,CAAC;AACrC,gBAAA,gBAA0B,CAAC,OAAO,GAAG,QAAQ,CAAC;AAC/C,gBAAA,gBAAgB,CAAC,IAAI,GAAG,SAAS;gBAEjC,MAAM,KAAK,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAQ;AAChD,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;AAEhC,oBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;oBAClD,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW;AAErC,oBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;AACtC,oBAAA,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC;gBAC9C;YAEJ;AAAO,iBAAA,IACH,IAAI,CAAC,OAAO,EAAE,KAAK,aAAa;iBAE5B,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc;AACjD,oBAAA,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,wBAAwB,CAC9D,EACH;AACE;;;AAGG;AACH,gBAAA,MAAM,cAAc,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,wBAAwB;AAC/E,sBAAE,IAAI,CAAC,MAAM,CAAC;AACd,sBAAE,IAAI,CAAC,MAA2B;gBAEtC,IAAI,cAAc,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc,EAAE;oBACtD;gBACJ;gBAEA,MAAM,SAAS,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE;AACvD,gBAAA,gBAAgB,CAAC,IAAI,GAAG,SAAS;gBAEjC,MAAM,KAAK,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAQ;AAChD,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;AAEhC,oBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;oBAClD,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW;AACrC,oBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;AAEtC,oBAAA,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC;gBAC9C;YAEJ;AAEA,YAAA,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,gBAAgB,EAAE;AACrD,gBAAA,gBAAgB,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE;YAC1C;YAEA,eAAe,GAAG,SAAS;YAE3B;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,cAAc;AAC7B;;;;;AAKG;YACH,IACI,CACI,CACK,IAA0B,CAAC,UAAU,EAAE,OAAO,EAAE,KAAK,eAAe;AACpE,gBAAA,IAA0B,CAAC,UAAU,EAAE,OAAO,EAAE,KAAK,QAAQ;AAElE,iBACK,IAA0B,CAAC,UAAU,EAAE,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,CAC/E;AAEJ,gBAAA,IAA0B,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,uBAAuB,EACzF;gBACE,MAAM,cAAc,GAAG,IAAyB;gBAEhD,IAAI,SAAS,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,EAAE;AAEtD,gBAAA,IAAI,CAAC,SAAS,IAAI,cAAc,CAAC,MAAM,CAAC,IAAI,KAAKA,aAAE,CAAC,UAAU,CAAC,mBAAmB,EAAE;oBAChF,SAAS,GAAI,cAAc,CAAC,MAAiC,CAAC,IAAI,EAAE,OAAO,EAAE;gBACjF;;gBAGA,IAAI,CAAC,SAAS,EAAE;oBAAE;gBAAO;AAEzB,gBAAA,IAAI,gBAAgB,EAAE,IAAI,KAAK,SAAS,EAAE;AACtC,oBAAA,gBAAgB,GAAG,IAAI,KAAK,EAAE;AAC9B,oBAAA,OAAO,CAAC,YAAY,CAAC,gBAAgB,CAAC;gBAC1C;AAEA,gBAAA,IAAK,IAA0B,CAAC,UAAU,EAAE,OAAO,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,KAAK,EAAE,EAAE;;oBAE9E,MAAM,YAAY,GAAI,IAAY,CAAC,UAAU,EAAE,UAAU,EAAE,WAAW;;oBAGtE,IAAI,CAAC,YAAY,EAAE;wBAAE;oBAAO;AAC3B,oBAAA,gBAA0B,CAAC,OAAO,GAAG,YAAY;gBAEtD;qBAAO;;AAEF,oBAAA,gBAA0B,CAAC,OAAO,GAAG,QAAQ,CAAC;gBACnD;AAEA,gBAAA,gBAAgB,CAAC,IAAI,GAAG,SAAS;gBAEjC,MAAM,KAAK,GAAG,cAAc,CAAC,SAAS,CAAC,CAAC,CAAQ;AAChD,gBAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;oBAC9C,MAAM,IAAI,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC;AAEhC,oBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;oBAClD,QAAQ,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,WAAW;AAErC,oBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;AACtC,oBAAA,cAAc,CAAC,QAAQ,EAAE,IAAI,CAAC,WAAW,CAAC;gBAC9C;YACJ;YAEA;AAEJ,QAAA,KAAKA,aAAE,CAAC,UAAU,CAAC,UAAU;AACzB,YAAA,IAAI,gBAAgB,YAAY,IAAI,EAAE;AAClC,gBAAA,MAAM,WAAW,GAAI,IAAY,CAAC,WAAW,EAAE,IAAI;gBACnD,MAAM,IAAI,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC,OAAO,EAAE;AAC3C,gBAAA,MAAM,QAAQ,GAAG,eAAe,IAAI,IAAI,QAAQ,EAAE;AAClD,gBAAA,QAAQ,CAAC,IAAI,GAAG,IAAI;AACpB,gBAAA,IAAI,WAAW,KAAK,SAAS,EAAE;AAC3B,oBAAA,QAAQ,CAAC,IAAI,GAAG,WAAW;gBAC/B;AACA,gBAAA,gBAAgB,CAAC,WAAW,CAAC,QAAQ,CAAC;gBACtC,eAAe,GAAG,SAAS;YAC/B;YACA;;AAGR,IAAAA,aAAE,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC,CAAU,KAAK,WAAW,CAAC,CAAC,EAAE,OAAO,EAAE,aAAa,CAAC,CAAC;AACjF;AAEA,IAAI,WAA4C;AAE1C,SAAU,UAAU,CACtB,SAAmB,EACnB,aAAA,GAAwB,MAAM,EAC9B,OAAA,GAAmB,IAAI,OAAO,EAAE,EAAA;AAEhC;;AAEG;AACH,IAAA,IAAI,aAAa,KAAK,OAAO,EAAE;QAC3B,WAAW,GAAG,EAAE;QAChB,aAAa,GAAG,OAAO;IAC3B;AAEA,IAAA,SAAS,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAI;AAC3B,QAAA,IAAI,UAAmB;AACvB,QAAA,IAAI,cAAsB;QAE1B,MAAM,oBAAoB,GAAG,EAAE;AAE/B,QAAA,IACI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC;AACzB,YAAA,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC;AACzB,YAAA,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,EAC5B;AACE,YAAA,oBAAoB,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAA,GAAA,CAAK,CAAC;AAC3C,YAAA,oBAAoB,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAA,SAAA,CAAW,CAAC;QAErD;AAAO,aAAA,IAAI,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;;AAEjC,YAAA,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC;AACnC,YAAA,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QAE/D;aAAO;AACH,YAAA,oBAAoB,CAAC,IAAI,CAAC,QAAQ,CAAC;QACvC;AAEA,QAAA,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;AAClD,YAAA,IAAI;gBACA,cAAc,GAAGF,eAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC,CAAC;AAEtD,gBAAA,IAAI,WAAW,CAAC,cAAc,CAAC,EAAE;oBAC7B;gBACJ;gBAEA,UAAU,GAAGE,aAAE,CAAC,gBAAgB,CAC5B,cAAc,EACdC,eAAY,CAAC,cAAc,CAAC,CAAC,QAAQ,EAAE,EACvCD,aAAE,CAAC,YAAY,CAAC,MAAM,EACtB,IAAI,CACP;AAED,gBAAA,WAAW,CAAC,cAAc,CAAC,GAAG,IAAI;gBAElC;YACJ;YAAE,OAAO,CAAC,EAAE;;YAEZ;QACJ;QAEA,IAAI,UAAU,EAAE;AACZ,YAAA,WAAW,CAAC,UAAU,EAAE,OAAO,EAAE,aAAa,CAAC;QACnD;AACJ,IAAA,CAAC,CAAC;AAEF,IAAA,OAAO,OAAO,CAAC,aAAa,EAAE;AAClC;AAEA;;;;AAIG;AACG,SAAU,aAAa,CAAC,IAAgC,EAAA;AAC1D,IAAA,IAAI,IAAI,IAAI,SAAS,EAAE;AAAE,QAAA,OAAO,SAAS;IAAE;;;AAI3C,IAAA,IAAI,IAAI,CAAC,UAAU,EAAE;QAAE,OAAO,IAAI,CAAC,UAAU;IAAE;;;IAI/C,IAAIA,aAAE,CAAC,iBAAiB,IAAIA,aAAE,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;;QAEpD,MAAM,UAAU,GAAGA,aAAE,CAAC,aAAa,CAAC,IAAI,CAAC;AACzC,QAAA,OAAO,UAAU,GAAG,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,SAAS;IAC1D;;IAGA,OAAO,IAAI,CAAC,SAAS,EAAE,MAAM,CAACA,aAAE,CAAC,WAAW,CAAC;AACjD;;AC3ZA,MAAME,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,OAAO;AACjB,IAAA,SAAS,EAAE,MAAM;AACjB,IAAA,MAAM,EAAE,OAAO;AACf,IAAA,OAAO,EAAE,MAAM;AACf,IAAA,OAAO,EAAE,OAAO;AAChB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,OAAO,EAAE,MAAM;AACf,IAAA,QAAQ,EAAE,OAAO;AACjB,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,SAAS,EAAE,QAAQ;CACtB;AAED;;AAEG;AACH,MAAMC,YAAU,GAAG,CAAC,CAAS,KAAI;IAC7B,IAAI,OAAO,CAAC,KAAK,QAAQ;AAAE,QAAA,OAAO,EAAE;AACpC,IAAA,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;AACjD,CAAC;AAEK,SAAUC,UAAQ,CAAC,OAAgB,EAAE,OAAwB,EAAA;;IAE/D,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,SAAS,KAAI;QAChCF,UAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,IAAI;AAC7C,IAAA,CAAC,CAAC;IACF,OAAO;QACH,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,KAAK;AACjC,YAAA,IAAI,EAAE,CAAA,EAAG,SAAS,CAAC,IAAI,CAAA,GAAA,CAAK;YAC5B,OAAO,EAAEG,eAAa,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS;AACtD,SAAA,CAAC,CAAC;QACH,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,KAAK;AACpC,YAAA,IAAI,EAAE,CAAA,EAAG,SAAS,CAAC,IAAI,CAAA,GAAA,CAAK;YAC5B,OAAO,EAAEC,mBAAiB,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC;AAC3D,SAAA,CAAC,CAAC;QACH,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,IAAI,SAAS,CAAC,IAAI,KAAK,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,SAAS,MAAM;AACrF,YAAA,IAAI,EAAE,CAAA,EAAG,SAAS,CAAC,IAAI,CAAA,GAAA,CAAK;YAC5B,OAAO,EAAE,YAAY,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC;AACtD,SAAA,CAAC,CAAC;KACN;AACL;AAEA,SAASD,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAA;AAClD,IAAA,MAAM,MAAM,GAAG,CAAC,SAAS,IAAI,IAAI,GAAG,EAAE;IACtC,OAAO,CAAA,EAAG,gBAAgB,EAAE;;;;;;EAM9B,SAAS,GAAG,CAAA,YAAA,EAAe,SAAS,CAAA,EAAA,CAAI,GAAG,EAAE;AAC7C,EAAA,MAAM,wBAAwB,KAAK,CAAC,IAAI,CAAA,GAAA,EAAM,KAAK,CAAC,OAAO,CAAA;;;;AAIpD,OAAA,EAAA,KAAK,CAAC,IAAI,CAAA;EACjB,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,KAAKE,kBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;EAC3E,MAAM,CAAA;AACN,EAAA,SAAS,GAAG,GAAG,GAAG,EAAE;CACrB;AACD;AAEA,SAAS,YAAY,CAAC,KAAW,EAAE,SAAiB,EAAA;IAChD,MAAM,MAAM,GAAG,SAAS,GAAG,IAAI,GAAG,EAAE;IACpC,OAAO,CAAA,EAAG,gBAAgB,EAAE;EAC9B,SAAS,GAAG,CAAA,YAAA,EAAe,SAAS,CAAA,EAAA,CAAI,GAAG,EAAE;EAC7C,MAAM,CAAA,cAAA,EAAiB,KAAK,CAAC,IAAI,CAAA;;AAEjC,EAAA,KAAK,CAAC;AACH,SAAA,GAAG,CAAC,CAAC,IAAI,KAAI;QACV,IAAI,QAAQ,GAAW,KAAK;AAC5B,QAAA,IAAI,KAAU;AAEd,QAAA,IAAG,IAAI,CAAC,IAAI,EAAE;YACV,IAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE;AACzB,gBAAA,KAAK,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;gBACxB,QAAQ,GAAG,QAAQ;YACvB;iBAAO;AACH,gBAAA,KAAK,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;AACzB,gBAAA,QAAQ,GAAG,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,GAAE,KAAK,GAAE,OAAO;YACtD;QACJ;aAAO;YACH,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,IAAI,CAAC;QAC1C;QACA,OAAO,CAAA,EAAG,MAAM,CAAA,eAAA,EAAkB,QAAQ,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,CAAA,GAAA,EAAM,KAAK,CAAA,CAAA,CAAG;AACzE,IAAA,CAAC;SACI,IAAI,CAAC,IAAI,CAAC;EACjB,MAAM,CAAA;EACN,SAAS,GAAG,GAAG,GAAG,EAAE,CAAA,CAAE;AACxB;AAEA,SAASA,kBAAgB,CAAC,IAAc,EAAE,SAAiB,EAAE,EAAA;AACzD,IAAA,IAAI,QAAQ,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;IAC/B,IAAI,QAAQ,GAAG,QAAQ;AACvB,IAAA,IAAI,QAAgB;IACpB,IAAI,WAAW,GAAG,EAAE;AAEpB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;AAEpD,QAAA,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;AACxB,QAAA,QAAQ,IAAI,CAAA,SAAA,EAAY,QAAQ,CAAA,CAAA,CAAG;QAEnC,IAAI,CAAC,aAAa,EAAE;AAChB,YAAA,QAAQ,IAAI,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,GAAG;QACvC;QAEA,WAAW,GAAG,MAAM;IAExB;SAAO;AACH,QAAA,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;AACxB,QAAA,WAAW,GAAG,CAAA,QAAA,EAAW,QAAQ,CAAA,CAAA,CAAG;IACxC;IAEA,QAAQ,IAAI,IAAI,QAAQ,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,EAAE;AAEvC,IAAA,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,CAAA,6BAAA,EAAgC,IAAI,CAAC,IAAI,CAAA,2BAAA,CAA6B,GAAG,EAAE;IAEzG,OAAO,GAAG,GAAG,CAAA,EAAA,EAAK,MAAM,SAAS,IAAI,CAAC,KAAK,CAAA,EAAA,EAAK,QAAQ,CAAA;AACxD,EAAA,EAAA,MAAM,CAAA,EAAG,QAAQ,CAAA,GAAA,EAAM,WAAW,GAAG;AACzC;AAEA,SAASD,mBAAiB,CAAC,MAAiB,EAAE,SAAiB,EAAA;AAC3D,IAAA,MAAM,MAAM,GAAG,CAAC,SAAS,IAAI,IAAI,GAAG,EAAE;IACtC,OAAO,CAAA,EAAG,gBAAgB,EAAE;;;EAG9B,SAAS,GAAG,CAAA,YAAA,EAAe,SAAS,CAAA,EAAA,CAAI,GAAG,EAAE;EAC7C,MAAM,CAAA,aAAA,EAAgB,MAAM,CAAC,IAAI,CAAA;EACjC,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAA,EAAA,EAAK,MAAM,CAAA,OAAA,EAAU,OAAO,CAAC,IAAI,CAAC,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;EAC5F,MAAM,CAAA;AACN,EAAA,SAAS,GAAG,GAAG,GAAG,EAAE;CACrB;AACD;AAEA,SAAS,YAAY,CAAC,IAAc,EAAA;AAChC,IAAA,OAAOJ,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;AACnC;AAEA,SAAS,OAAO,CAAC,IAAc,EAAA;AAC3B,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;AACpD,QAAA,IAAI,IAAY;AAEhB,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YACpB,IAAI,GAAG,CAAC,aAAa;kBACf,IAAI,CAAC;AACP,kBAAE,YAAY,CAAC,IAAI,CAAC;QAC5B;aAAO;YACH,MAAM,cAAc,GAAGC,YAAU,CAAC,IAAI,CAAC,IAAI,CAAC;YAC5C,IAAI,GAAG,CAAC,aAAa;AACjB,kBAAE,CAAA,EAAG,cAAc,UAAU,IAAI,CAAC,SAAS,CAAA,CAAA;kBACzC,GAAG,cAAc,CAAA,OAAA,EAAU,YAAY,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG;QAC1D;AACA,QAAA,OAAO,IAAI;IAEf;SAAO;AACH,QAAA,OAAO,CAAC,IAAI,CAAC,IAAI,KAAK,OAAO;AACzB,cAAE,CAAA,EAAGD,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,SAAS,CAAA,EAAA;AAC/C,cAAEA,UAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IAC7B;AACJ;;AC5KA,MAAMA,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,UAAU;AACpB,IAAA,SAAS,EAAE,MAAM;AACjB,IAAA,MAAM,EAAE,QAAQ;AAChB,IAAA,OAAO,EAAE,SAAS;AAClB,IAAA,OAAO,EAAE,SAAS;AAClB,IAAA,QAAQ,EAAE,UAAU;AACpB,IAAA,OAAO,EAAE,SAAS;AAClB,IAAA,QAAQ,EAAE,UAAU;AACpB,IAAA,OAAO,EAAE,SAAS;AAClB,IAAA,QAAQ,EAAE,UAAU;AACpB,IAAA,SAAS,EAAE,WAAW;AACtB,IAAA,SAAS,EAAE,WAAW;CACzB;AAED,MAAMM,iBAAe,GAA8B;AAC/C,IAAA,QAAQ,EAAE,IAAI;AACd,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,MAAM,EAAE,GAAG;AACX,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,GAAG;AACd,IAAA,SAAS,EAAE,GAAG;CACjB;AAED;;AAEG;AAEH,MAAM,UAAU,GAAG,CAAC,CAAS,KAAI;IAC7B,IAAI,OAAO,CAAC,KAAK,QAAQ;AAAE,QAAA,OAAO,EAAE;AACpC,IAAA,OAAO,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;AACjD,CAAC;AACD,MAAMC,UAAQ,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,IAAc,KAC1D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK;AAE3B,SAAUL,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK;AACjC,QAAA,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,MAAM;AACzB,QAAA,OAAO,EAAEC,eAAa,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO;AACnE,KAAA,CAAC,CAAC;AACP;AAEA,SAASA,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACvE,MAAM,iBAAiB,GAAiC,EAAE;IAC1D,MAAM,OAAO,GAAe,EAAE;AAC9B,IAAA,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,IAAG;AAChC,QAAA,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI;AAExB,QAAA,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;AAC1B,YAAA,iBAAiB,CAAC,IAAI,CAAC,GAAG,EAAE;QAChC;QAEA,iBAAiB,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;;AAGtC,QAAA,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,KAAK,GAAG;AACxD,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B;AACJ,IAAA,CAAC,CAAC;IAEF,MAAM,aAAa,GAAG,gBAAgB,CAAC,KAAK,EAAE,UAAU,CAAC;AACzD,IAAA,MAAM,oBAAoB,GAAG,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,IAAI,EAAE;AACxD,QAAA,CAAA;AACE,IAAA,EAAA,wBAAwB,CAAC,OAAO,EAClC,CAAC,QAAQ,KAAK,CAAA,eAAA,EAAkB,QAAQ,CAAC,SAAS,CAAA,CAAA,CAAG,EACrD,CAAC,QAAQ,KAAK,CAAA,WAAA,EAAc,QAAQ,CAAC,SAAS,CAAA,GAAA,CAAK,EACnD,CAAC,QAAQ,KAAKH,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;AAChD,WAAA,EAAA,KAAK,CAAC,OAAO,CAAA;IACtB;IAEA,OAAO,CAAA,EAAG,gBAAgB,EAAE;AACL,yBAAA,EAAA,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAA;AACxB,yBAAA,EAAA,KAAK,CAAC,IAAI,CAAC,WAAW,EAAE,CAAA;;;;;;EAMjD,OAAO;AACL,QAAA,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,IAAIA,UAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;QACrE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;QACzB,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7E,MAAM,CAACO,UAAQ,CAAC;QAChB,GAAG,CAAC,SAAS,IAAI,CAAA,UAAA,EAAa,SAAS,OAAO,CAAC;QAC/C,IAAI,CAAC,IAAI,CAAC;;;;EAIZ,SAAS,GAAG,CAAA,UAAA,EAAa,SAAS,CAAA,EAAA,CAAI,GAAG,EAAE;AACrC,MAAA,EAAA,KAAK,CAAC,IAAI,CAAA,UAAA,EAAa,KAAK,CAAC,OAAO,CAAA;;AAE1C,EAAA,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAIF,kBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;AAE7D,EAAA,EAAA,KAAK,CAAC,IAAI,CAAA;uBACS,kBAAkB,CAAC,aAAa,CAAC,CAAA;qBACnC,gBAAgB,CAAC,aAAa,CAAC,CAAA;mCACjB,8BAA8B,CAAC,aAAa,CAAC,CAAA;gCAChD,2BAA2B,CAAC,aAAa,CAAC,CAAA;;;AAG7D,WAAA,EAAA,KAAK,CAAC,IAAI,CAAA;AACjB,IAAA,EAAA,mBAAmB,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC;;;;EAIrD,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC,GAAG,CAAC,IAAI,IACrC,yBAAyB,CAAC,KAAK,EAAE,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC,CAAC;QAChE,IAAI,CAAC,IAAI,CAAC;;EAEZ,oBAAoB;;AAEpB,EAAA,SAAS,GAAG,GAAG,GAAG,EAAE;;;CAGrB;AACD;AAEA,SAASA,kBAAgB,CAAC,IAAc,EAAA;IACpC,IAAI,QAAQ,GAAG,EAAE;AACjB,IAAA,IAAI,QAAgB;IACpB,IAAI,WAAW,GAAG,EAAE;IACpB,IAAI,aAAa,GAAG,EAAE;AAEtB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;AAEpD,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACpB,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;AAC9B,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,IAAI,CAAC,SAAS,IAAI;QAE3C;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YAC7B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,YAAA,EAAe,IAAI,CAAC,SAAS,CAAA,EAAA;kBAC7B,eAAeL,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAChD,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;QAErC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC3B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,UAAA,EAAa,IAAI,CAAC,SAAS,CAAA,EAAA;kBAC3B,aAAaA,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAC9C,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;QACrC;QACA,aAAa,GAAG,GAAG;IAEvB;SAAO;AACH,QAAA,QAAQ,GAAGA,UAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;AAC9B,QAAA,WAAW,GAAGM,iBAAe,CAAC,IAAI,CAAC,IAAI,CAAC;IAC5C;IAEA,QAAQ,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA,EAAI,aAAa,GAAG,IAAI,CAAC,IAAI,CAAA,CAAE;AAEvD,IAAA,OAAO,CAAA,EAAA,EAAK,QAAQ,CAAA,GAAA,EAAM,WAAW,GAAG;AAC5C;AAEA,SAAS,yBAAyB,CAAC,KAAY,EAAE,IAAY,EAAE,UAAsB,EAAA;AACjF,IAAA,IAAI,QAAQ,GAAGN,UAAQ,CAAC,IAAI,CAAC;IAC7B,IAAI,QAAQ,GAAG,EAAE;IAEjB,MAAM,aAAa,GAAG,CAAA,GAAA,EAAM,UAAU,CAAC,IAAI,CAAC,EAAE;IAC9C,MAAM,aAAa,GAAG,CAAA,GAAA,EAAM,UAAU,CAAC,IAAI,CAAC,EAAE;AAE9C,IAAA,IAAI,IAAI,KAAK,KAAK,EAAE;QAChB,QAAQ,GAAG,SAAS;IAExB;AAAO,SAAA,IAAI,IAAI,KAAK,OAAO,EAAE;QACzB,QAAQ,GAAG,sBAAsB;QACjC,QAAQ,GAAG,wBAAwB;IAEvC;AAAO,SAAA,IAAI,IAAI,KAAK,KAAK,EAAE;QACvB,QAAQ,GAAG,oBAAoB;QAC/B,QAAQ,GAAG,sBAAsB;IACrC;IAEA,OAAO,CAAA,SAAA,EAAY,QAAQ,CAAA,CAAA,EAAI,aAAa,CAAA;;MAE1C,wBAAwB,CAAC,UAAU,EACrC,CAAC,QAAQ,KAAK,CAAA,UAAA,EAAa,QAAQ,CAAC,IAAI,CAAA,CAAA,CAAG,EAC3C,CAAC,QAAQ,KAAK,CAAA,OAAA,EAAU,QAAQ,CAAA,MAAA,EAAS,QAAQ,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC;aACjD,KAAK,CAAC,OAAO,CAAA,EAAA,EAAK,aAAa,CAAA;;;AAG5B,cAAA,EAAA,aAAa,yBAAyB,QAAQ,CAAA;;AAExD,IAAA,EAAA,wBAAwB,CAAC,UAAU,EACrC,CAAC,QAAQ,KAAK,CAAA,UAAA,EAAa,QAAQ,CAAC,IAAI,CAAA,CAAA,CAAG,EAC3C,CAAC,QAAQ,KAAI;AACT,QAAA,MAAM,YAAY,IAAIA,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;AAEjE,QAAA,IAAI,IAAI,KAAK,KAAK,EAAE;AAChB,YAAA,QAAQ,GAAG,CAAA,EAAG,QAAQ,CAAC,SAAS,GAAG;YACnC,QAAQ,GAAG,CAAC,YAAY;AACpB,kBAAE,CAAA,CAAA,EAAI,QAAQ,CAAC,SAAS,CAAA,EAAA;kBACtB,YAAY;QAEtB;AAAO,aAAA,IAAI,IAAI,KAAK,OAAO,EAAE;YACzB,QAAQ,GAAG,CAAC,YAAY;AACpB,kBAAE,CAAA,aAAA,EAAgB,QAAQ,CAAC,SAAS,CAAA,KAAA;kBAClC,gBAAgBA,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAA,IAAA,CAAM;QAE5D;AAAO,aAAA,IAAI,IAAI,KAAK,KAAK,EAAE;YACvB,QAAQ,GAAG,CAAC,YAAY;AACpB,kBAAE,CAAA,WAAA,EAAc,QAAQ,CAAC,SAAS,CAAA,KAAA;kBAChC,cAAcA,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAA,IAAA,CAAM;QAC1D;AAEA,QAAA,OAAO,SAAS,QAAQ,CAAC,IAAI,CAAA,GAAA,EAAM,QAAQ,uBAAuB;AACtE,IAAA,CAAC,CAAC;aACO,KAAK,CAAC,OAAO,CAAA,EAAA,EAAK,aAAa,CAAA;IACxC;AACJ;AAEA,SAAS,wBAAwB,CAC7B,UAAsB,EACtB,UAA0C,EAC1C,QAAwC,EACxC,MAAA,GAA0C,CAAC,CAAC,KAAK,IAAI,EAAA;IAErD,IAAI,KAAK,GAAG,EAAE;IAEd,MAAM,YAAY,GAAa,EAAE;AACjC,IAAA,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAI;AAC9C,QAAA,MAAM,KAAK,GAAG,UAAU,CAAC,QAAQ,CAAC;QAClC,IAAI,YAAY,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,EAAE,EAAE;AACpC,YAAA,YAAY,CAAC,IAAI,CAAC,KAAK,CAAC;QAE5B;aAAO;YACH;QACJ;AAEA,QAAA,IAAI,CAAC,KAAK,CAAC,EAAE;YAAE,KAAK,IAAI,KAAK;QAAC;aAAO;YAAE,KAAK,IAAI,WAAW;QAAC;QAC5D,KAAK,IAAI,IAAI,KAAK,CAAA;;QAElB,QAAQ,CAAC,QAAQ,CAAC,CAAA;MACpB;AACF,IAAA,CAAC,CAAC;AAEF,IAAA,OAAO,KAAK;AAChB;AAEA,SAAS,kBAAkB,CAAC,UAAsB,EAAA;IAC9C,OAAO,CAAA,CAAA,EAAI,UAAU,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAA,CAAA,EAAI,CAAC,CAAA,GAAA,EAAM,QAAQ,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG;AAE1F;AAEA,SAAS,gBAAgB,CAAC,UAAsB,EAAA;IAC5C,OAAO,CAAA,CAAA,EAAI,UAAU,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAA,CAAA,EAAI,CAAC,CAAA,GAAA,EAAM,QAAQ,CAAC,IAAI,CAAA,EAAA,CAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA,CAAA,CAAG;AAC1F;AAEA,SAAS,2BAA2B,CAAC,UAAsB,EAAA;IACvD,OAAO,CAAA,CAAA,EAAI,UAAU,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAI;AACtC,QAAA,IAAI,QAAQ,CAAC,SAAS,IAAIA,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,SAAS,EAAE;AAClE,YAAA,OAAO,IAAI,CAAC,CAAA,SAAA,EAAY,QAAQ,CAAC,SAAS,IAAI;QAClD;aAAO;AACH,YAAA,OAAO,IAAI;QACf;AACJ,IAAA,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AAC5C;AAEA,SAAS,8BAA8B,CAAC,UAAsB,EAAA;IAC1D,OAAO,CAAA,CAAA,EAAI,UAAU,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAI;QACtC,IAAIA,UAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,KAAK,SAAS,EAAE;AAC5C,YAAA,OAAO,IAAI,CAAC,CAAA,GAAA,EAAM,QAAQ,CAAC,SAAS,IAAI;QAC5C;aAAO;AACH,YAAA,OAAO,IAAI;QACf;AACJ,IAAA,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG;AAC5C;AAEA,SAAS,mBAAmB,CAAC,UAAsB,EAAA;IAC/C,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC,KAAI;AAClC,QAAA,IAAI,QAAQ,CAAC,SAAS,EAAE;AACpB,YAAA,OAAO,CAAA,aAAA,EAAgB,QAAQ,CAAC,IAAI,GAAG;QAC3C;aAAO;AACH,YAAA,OAAO,IAAI;QACf;AACJ,IAAA,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC;AAC9B;AAEA,SAAS,gBAAgB,CAAE,KAAY,EAAE,UAAmB,EAAA;IACxD,IAAI,UAAU,GAAe,EAAE;AAE/B,IAAA,kBAAkB,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC,OAAO,EAAE,CAAC,OAAO,CAAC,CAAC,KAAK,KAAI;QAC9D,UAAU,GAAG,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC;AACpD,IAAA,CAAC,CAAC;AAEF,IAAA,OAAO,UAAU;AACrB;;ACtSA,MAAMA,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,SAAS;AACnB,IAAA,SAAS,EAAE,MAAM;AACjB,IAAA,MAAM,EAAE,KAAK;AACb,IAAA,OAAO,EAAE,MAAM;AACf,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,SAAS,EAAE,OAAO;CACrB;AAED,MAAMM,iBAAe,GAA8B;AAC/C,IAAA,QAAQ,EAAE,IAAI;AACd,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,MAAM,EAAE,GAAG;AACX,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,GAAG;AACd,IAAA,SAAS,EAAE,GAAG;CACjB;AAEK,SAAUJ,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK;AACjC,QAAA,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,KAAK;AACxB,QAAA,OAAO,EAAEC,eAAa,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO;AACnE,KAAA,CAAC,CAAC;AACP;AAkBA,SAASA,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACvE,OAAO,CAAA,EAAG,gBAAgB,EAAE;;EAE9B,SAAS,GAAG,CAAA,QAAA,EAAW,SAAS,CAAA,CAAA,CAAG,GAAG,EAAE;;;;AAIlC,MAAA,EAAA,KAAK,CAAC,IAAI,CAAA,SAAA,EAAY,KAAK,CAAC,OAAO,CAAA;AACzC,EAAA,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAIE,kBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;CAEhE;AACD;AAEA,SAASA,kBAAgB,CAAC,IAAc,EAAA;AACpC,IAAA,IAAI,QAAgB;IACpB,IAAI,WAAW,GAAG,EAAE;AACpB,IAAA,IAAI,QAAQ,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;AAE/B,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;QAEpD,IAAI,aAAa,EAAE;AACf,YAAA,QAAQ,IAAI,CAAA,EAAA,EAAK,IAAI,CAAC,SAAS,EAAE;QAErC;aAAO;AACH,YAAA,QAAQ,IAAI,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,GAAG;QACvC;AAEA,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACpB,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;AAC9B,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,IAAI,CAAC,SAAS,IAAI;QAE3C;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YAC7B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,YAAA,EAAe,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC7B,eAAeL,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAChD,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;QAErC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC3B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,UAAA,EAAa,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC3B,aAAaA,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAC9C,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;QACrC;IAEJ;SAAO;AACH,QAAA,QAAQ,GAAGA,UAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;AAC9B,QAAA,WAAW,GAAGM,iBAAe,CAAC,IAAI,CAAC,IAAI,CAAC;IAC5C;;;IAKA,OAAO,CAAA,SAAA,EAAY,QAAQ,CAAA,gBAAA,EAAmB,IAAI,CAAC,IAAI,CAAA,EAAA,EAAK,QAAQ,CAAA,GAAA,EAAM,WAAW,CAAA,GAAA,CAAK;;AAE9F;;AC9GA,MAAMN,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,MAAM,EAAE,QAAQ;AAChB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,QAAQ;AACnB,IAAA,SAAS,EAAE,QAAQ;CACtB;AAED,MAAMO,UAAQ,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,IAAc,KAC1D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK;AAE3B,SAAUL,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO;QACH,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,KAAK;AACjC,YAAA,IAAI,EAAE,SAAS,CAAC,IAAI,GAAG,KAAK;AAC5B,YAAA,OAAO,EAAEC,eAAa,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO;AACvE,SAAA,CAAC,CAAC;QACH,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,KAAK;AACpC,YAAA,IAAI,EAAE,SAAS,CAAC,IAAI,GAAG,KAAK;AAC5B,YAAA,OAAO,EAAE,iBAAiB,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO,CAAC;AAC5E,SAAA,CAAC;KACL;AACL;AAEA,SAASA,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACvE,MAAM,OAAO,GAAe,EAAE;AAC9B,IAAA,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,IAAG;AAChC,QAAA,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI;;AAGxB,QAAA,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,GAAG;AAC1E,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B;AACJ,IAAA,CAAC,CAAC;IAEF,OAAO,CAAA,EAAG,gBAAgB,EAAE;;;EAG9B,OAAO;AACL,QAAA,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,IAAIH,UAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;QACrE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;QACzB,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7E,MAAM,CAACO,UAAQ,CAAC;QAChB,GAAG,CAAC,SAAS,IAAI,YAAY,SAAS,CAAA,WAAA,EAAc,SAAS,CAAA,CAAA,CAAG,CAAC;QACjE,IAAI,CAAC,IAAI,CAAC;;AAEC,aAAA,EAAA,KAAK,CAAC,IAAI,CAAA,SAAA,EAAY,KAAK,CAAC,OAAO,CAAA;EAChD,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAA,IAAA,EAAOF,kBAAgB,CAAC,IAAI,CAAC,CAAA,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;CAEzE;AACD;AAEA,SAASA,kBAAgB,CAAC,IAAc,EAAA;AACpC,IAAA,IAAI,QAAgB;IACpB,IAAI,WAAW,GAAG,EAAE;AACpB,IAAA,IAAI,QAAgB;AAEpB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;QAEpD,IAAI,aAAa,EAAE;AACf,YAAA,QAAQ,IAAI,CAAA,EAAA,EAAK,IAAI,CAAC,SAAS,EAAE;QAErC;aAAO;AACH,YAAA,QAAQ,IAAI,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,GAAG;QACvC;AAEA,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACpB,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;AAC9B,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,IAAI,CAAC,SAAS,IAAI;AACvC,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;QAElC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YAC7B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,YAAA,EAAe,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC7B,eAAeL,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAChD,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;YACjC,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,EAAA,EAAK,IAAI,CAAC,SAAS,CAAA,EAAA;AACrB,kBAAE,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,KAAK;QAEnC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC3B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,UAAA,EAAa,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC3B,aAAaA,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAC9C,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;YACjC,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,OAAA,EAAU,IAAI,CAAC,SAAS,CAAA,EAAA;AAC1B,kBAAE,CAAA,QAAA,EAAW,IAAI,CAAC,SAAS,KAAK;QACxC;AAAO,aAAA,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC5B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,UAAA,EAAa,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC3B,aAAaA,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAA,CAAA,CAAG;AAC9C,YAAA,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAA,CAAI;YACjC,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,OAAA,EAAU,IAAI,CAAC,SAAS,CAAA,EAAA;AAC1B,kBAAE,CAAA,QAAA,EAAW,IAAI,CAAC,SAAS,KAAK;QACxC;IAEJ;SAAO;AACH,QAAA,QAAQ,GAAGA,UAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;AAC9B,QAAA,QAAQ,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;IAC/B;;IAGA,MAAM,iBAAiB,GAAG,WAAW,GAAG,EAAE,GAAG,GAAG;IAEhD,OAAO,CAAA,MAAA,EAAS,QAAQ,CAAA,SAAA,EAAY,IAAI,CAAC,IAAI,CAAA,EAAG,iBAAiB,CAAA,EAAA,EAAK,QAAQ,CAAA,EAAG,CAAC,WAAW,IAAI,CAAA,GAAA,EAAM,WAAW,CAAA,CAAE,GAAG,EAAE,CAAA,CAAA,CAAG;AAChI;AAGA,SAAS,iBAAiB,CAAC,SAAoB,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACnF,OAAO,CAAA,EAAG,gBAAgB,EAAE;;AAEb,iBAAA,EAAA,SAAS,CAAC,IAAI,CAAA;EAC/B,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAA,IAAA,EAAO,IAAI,CAAC,IAAI,CAAA,EAAA,EAAK,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;CAE/E;AACD;;AC9HA,MAAMA,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,MAAM,EAAE,QAAQ;AAChB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,QAAQ;AACnB,IAAA,SAAS,EAAE,QAAQ;CACtB;AAED,MAAMO,UAAQ,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,IAAc,KAC1D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK;AAE3B,SAAUL,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK;AACjC,QAAA,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,KAAK;AACxB,QAAA,OAAO,EAAEC,eAAa,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO;AACnE,KAAA,CAAC,CAAC;AACP;AAEA,SAASA,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACvE,MAAM,OAAO,GAAe,EAAE;AAC9B,IAAA,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,IAAG;AAChC,QAAA,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI;;AAGxB,QAAA,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,KAAK,GAAG;AACxD,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B;AACJ,IAAA,CAAC,CAAC;IAEF,OAAO,CAAA,EAAG,gBAAgB,EAAE;;;;;EAK9B,OAAO;AACL,QAAA,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,IAAIH,UAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;QACrE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;QACzB,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7E,MAAM,CAACO,UAAQ,CAAC;QAChB,GAAG,CAAC,SAAS,IAAI,SAAS,SAAS,CAAA,cAAA,EAAiB,SAAS,CAAA,GAAA,CAAK,CAAC;QACnE,IAAI,CAAC,IAAI,CAAC;;AAEN,MAAA,EAAA,KAAK,CAAC,IAAI,CAAA,SAAA,EAAY,KAAK,CAAC,OAAO,CAAA;;;AAGzC,EAAA,KAAK,CAAC,UAAU;QACd,MAAM,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC;AAC5C,QAAA,GAAG,CAAC,IAAI,IAAI,UAAU,GAAG,2BAA2B,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;;EAGxE,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAIC,6BAA2B,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;;AAEvE,eAAA,EAAA,KAAK,CAAC,IAAI,CAAA;CAC1B;AACD;AAEA,SAASA,6BAA2B,CAAC,SAAiB,EAAE,IAAc,EAAA;AAClE,IAAA,IAAI,QAAgB;AAEpB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;QAEpD,IAAI,aAAa,EAAE;AACf,YAAA,QAAQ,IAAI,CAAA,EAAA,EAAK,IAAI,CAAC,SAAS,EAAE;QAErC;aAAO;AACH,YAAA,QAAQ,IAAI,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,GAAG;QACvC;AAEA,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACpB,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;QAElC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YAC7B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,EAAA,EAAK,IAAI,CAAC,SAAS,CAAA,EAAA;AACrB,kBAAE,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,KAAK;QAEnC;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC3B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,OAAA,EAAU,IAAI,CAAC,SAAS,CAAA,EAAA;AAC1B,kBAAE,CAAA,QAAA,EAAW,IAAI,CAAC,SAAS,KAAK;QACxC;IAEJ;SAAO;AACH,QAAA,QAAQ,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;IAC/B;IAEA,OAAO,CAAA,KAAA,EAAQ,QAAQ,CAAA,EAAA,EAAK,SAAS,gBAAgB,IAAI,CAAC,IAAI,CAAA,GAAA,CAAK;AACvE;AAEA,SAAS,2BAA2B,CAAC,IAAc,EAAA;IAC/C,IAAI,WAAW,GAAG,EAAE;AAEpB,IAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AACpB,QAAA,WAAW,GAAG,CAAA,IAAA,EAAO,IAAI,CAAC,SAAS,IAAI;IAE3C;AAAO,SAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;QAC7B,WAAW,GAAG,0BAA0B;IAE5C;AAAO,SAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;QAC3B,WAAW,GAAG,wBAAwB;IAC1C;AAEA,IAAA,OAAO,QAAQ,IAAI,CAAC,IAAI,CAAA,GAAA,EAAM,WAAW,EAAE;AAC/C;;AChHA,MAAMR,UAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,OAAO;AACjB,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,MAAM,EAAE,MAAM;AACd,IAAA,OAAO,EAAE,OAAO;AAChB,IAAA,OAAO,EAAE,OAAO;AAChB,IAAA,QAAQ,EAAE,KAAK;AACf,IAAA,OAAO,EAAE,KAAK;AACd,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,OAAO,EAAE,MAAM;AACf,IAAA,QAAQ,EAAE,MAAM;AAChB,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,SAAS,EAAE,QAAQ;CACtB;AAED,MAAM,eAAe,GAA8B;AAC/C,IAAA,QAAQ,EAAE,IAAI;AACd,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,OAAO;AAClB,IAAA,MAAM,EAAE,GAAG;AACX,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,OAAO,EAAE,GAAG;AACZ,IAAA,QAAQ,EAAE,GAAG;AACb,IAAA,SAAS,EAAE,GAAG;AACd,IAAA,SAAS,EAAE,GAAG;CACjB;AAED;;AAEG;AAEG,SAAUE,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK;AACjC,QAAA,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,OAAO;QAC1B,OAAO,EAAEC,eAAa,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS;AAClD,KAAA,CAAC,CAAC;AACP;AAEA,SAASA,eAAa,CAAC,KAAY,EAAE,SAAiB,EAAA;AAClD,IAAA,MAAM,MAAM,GAAG,CAAC,SAAS,IAAI,IAAI,GAAG,EAAE;IACtC,OAAO,CAAA,EAAG,gBAAgB,EAAE;EAC9B,SAAS,GAAG,CAAA,UAAA,EAAa,SAAS,CAAA,CAAA,CAAG,GAAG,EAAE;;;;;;;AAO1C,EAAA,MAAM,gBAAgB,KAAK,CAAC,IAAI,CAAA,SAAA,EAAY,KAAK,CAAC,OAAO,CAAA;EACzD,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,gBAAgB,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC;EACzE,MAAM,CAAA;AACN,EAAA,SAAS,GAAG,GAAG,GAAG,EAAE;CACrB;AACD;AAEA,SAAS,gBAAgB,CAAC,IAAc,EAAE,SAAiB,EAAE,EAAA;IACzD,IAAI,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,KAAK,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,CAAA,CAAE;IAC3C,IAAI,QAAQ,GAAG,QAAQ;AACvB,IAAA,IAAI,QAAgB;IACpB,IAAI,QAAQ,GAAW,EAAE;IACzB,IAAI,WAAW,GAAG,EAAE;AAEpB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;QAEpD,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,aAAa,EAAE;AACtC,YAAA,QAAQ,GAAG,CAAA,EAAG,IAAI,CAAC,SAAS,QAAQ;QACxC;AAEA,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YACpB,QAAQ,GAAG,CAAC,aAAa;kBACnB,IAAI,CAAC;AACP,kBAAEH,UAAQ,CAAC,IAAI,CAAC,SAAS,CAAC;YAE9B,WAAW,GAAG,CAAA,IAAA,EAAO,QAAQ,CAAA,EAAG,CAAC,IAAI,CAAC,IAAI,KAAK,KAAK,IAAI,aAAa,IAAI,IAAI,GAAG,EAAE,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA,CAAG;QAErG;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;YAC7B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,YAAA,EAAe,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC7B,aAAa;AAEnB,YAAA,WAAW,GAAG,CAAA,eAAA,EAAkB,CAAC,aAAa,IAAI,IAAI,GAAG,EAAE,CAAA,CAAA,EAAI,QAAQ,GAAG;QAE9E;AAAO,aAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YAC3B,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,UAAA,EAAa,IAAI,CAAC,SAAS,CAAA,CAAA;kBAC3B,WAAW;AAEjB,YAAA,WAAW,GAAG,CAAA,aAAA,EAAgB,CAAC,aAAa,IAAI,IAAI,GAAG,EAAE,CAAA,CAAA,EAAI,QAAQ,GAAG;QAC5E;AAEA,QAAA,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YACrB,QAAQ,IAAI,CAAC,aAAa;AACtB,kBAAE,CAAA,IAAA;AACF,kBAAE,CAAA,CAAA,EAAI,IAAI,CAAC,SAAS,EAAE;QAC9B;IAEJ;SAAO;AACH,QAAA,QAAQ,GAAGA,UAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;AAC9B,QAAA,WAAW,GAAG,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC;IAC5C;IAEA,QAAQ,IAAI,IAAI,QAAQ,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,EAAE;IAEvC,OAAO,CAAA,gBAAA,EAAmB,QAAQ,CAAA,IAAA,EAAO,MAAM;AAC/C,EAAA,EAAA,MAAM,CAAA,EAAG,QAAQ,CAAA,GAAA,EAAM,WAAW,GAAG;AACzC;;AC/GA;;;;AAIE;AAEF,MAAM,QAAQ,GAA8B;AACxC,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,SAAS;AACpB,IAAA,MAAM,EAAE,QAAQ;AAChB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,OAAO,EAAE,QAAQ;AACjB,IAAA,QAAQ,EAAE,QAAQ;AAClB,IAAA,SAAS,EAAE,QAAQ;AACnB,IAAA,SAAS,EAAE,QAAQ;CACtB;AAED,MAAM,QAAQ,GAAG,CAAC,KAAa,EAAE,KAAa,EAAE,IAAc,KAC1D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,KAAK,KAAK;AAE3B,SAAUE,UAAQ,CAAE,OAAgB,EAAE,OAAwB,EAAA;IAChE,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,KAAK;AACjC,QAAA,IAAI,EAAE,KAAK,CAAC,IAAI,GAAG,MAAM;AACzB,QAAA,OAAO,EAAE,aAAa,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,EAAE,OAAO,CAAC,OAAO;AACnE,KAAA,CAAC,CAAC;AACP;AAEA,SAAS,aAAa,CAAC,KAAY,EAAE,SAAiB,EAAE,UAAmB,EAAA;IACvE,MAAM,OAAO,GAAe,EAAE;AAC9B,IAAA,KAAK,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,IAAG;AAChC,QAAA,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI;;AAGxB,QAAA,KAAK,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,KAAK,KAAK,GAAG;AACxD,YAAA,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;QAC1B;AACJ,IAAA,CAAC,CAAC;;IAGF,MAAM,QAAQ,GAAG,CAAC,KAAK,CAAC,OAAO,KAAK,QAAQ;AACxC,UAAE,CAAA,EAAA,EAAK,KAAK,CAAC,OAAO,CAAA;UAClB,EAAE;IAER,OAAO,CAAA,EAAG,gBAAgB,EAAE,CAAC,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC;;;EAGtD,OAAO;AACL,QAAA,MAAM,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,IAAI,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,SAAS,CAAC;QACrE,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;QACzB,MAAM,CAAC,kBAAkB,CAAC,KAAK,EAAE,UAAU,EAAE,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,CAAC;QAC7E,MAAM,CAAC,QAAQ,CAAC;QAChB,GAAG,CAAC,SAAS,IAAI,SAAS,SAAS,CAAA,YAAA,GAAgB,SAAS,GAAG,CAAA,EAAG,SAAS,CAAA,CAAA,CAAG,GAAG,EAAE,EAAC,EAAG,SAAS,CAAA,CAAA,CAAG,CAAC;QACpG,IAAI,CAAC,IAAI,CAAC;;AAEF,UAAA,EAAA,KAAK,CAAC,IAAI,CAAA,EAAA,EAAK,KAAK,CAAC,OAAO;EACtC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,CAAA,UAAA,EAAa,IAAI,CAAC,IAAI,CAAA,CAAA,EAAI,oBAAoB,CAAC,IAAI,CAAC,CAAA,CAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC;AACzF,MAAA,EAAA,KAAK,CAAC,IAAI,CAAA;AAChB,EAAA,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,2BAA2B,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;AAC9C,6BAAA,EAAA,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;GACrF,QAAQ,CAAA;;AAEF,OAAA,EAAA,KAAK,CAAC,IAAI;CAClB;AACD;AAEA,SAAS,2BAA2B,CAAC,IAAc,EAAA;AAC/C,IAAA,IAAI,QAAgB;AAEpB,IAAA,IAAI,IAAI,CAAC,SAAS,EAAE;QAChB,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,CAAC;QAEpD,IAAI,aAAa,EAAE;AACf,YAAA,QAAQ,IAAI,CAAA,EAAG,IAAI,CAAC,SAAS,EAAE;QAEnC;aAAO;AACH,YAAA,QAAQ,IAAI,CAAA,CAAA,EAAI,IAAI,CAAC,SAAS,GAAG;QACrC;AAEA,QAAA,IAAG,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;YACpB,QAAQ,GAAG,CAAC,aAAa;AACrB,kBAAE,CAAA,EAAG,IAAI,CAAC,SAAS,CAAA;AACnB,kBAAE,CAAA,CAAA,EAAI,IAAI,CAAC,SAAS,GAAG;QAE/B;aAAO;YACH,QAAQ,GAAG,CAAC,aAAa;kBACnB,KAAK,IAAI,CAAC,IAAI,CAAA,GAAA,EAAM,IAAI,CAAC,SAAS,CAAA,EAAA;kBAClC,CAAA,EAAA,EAAK,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC,SAAS,CAAA,GAAA,CAAK;QAClD;IAEJ;SAAO;AACH,QAAA,QAAQ,GAAG,CAAA,CAAA,EAAI,IAAI,CAAC,IAAI,GAAG;IAC/B;AAEA,IAAA,OAAO,SAAS,IAAI,CAAC,IAAI,CAAA,KAAA,EAAQ,QAAQ,EAAE;AAC/C;AAEA,SAAS,oBAAoB,CAAC,IAAc,EAAA;AACxC,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;QACrB,OAAO,IAAI,CAAC,SAAS;IAEzB;AAAO,SAAA,IAAI,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE;AAC9B,QAAA,OAAO,aAAa;IAExB;AAAO,SAAA,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK,EAAE;AAC5B,QAAA,OAAO,WAAW;IAEtB;SAAO;AACH,QAAA,OAAO,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC;IAC9B;AACJ;;ACtGA,MAAM,UAAU,GAA6B,UAAEO,UAAM,OAAEC,UAAG,QAAEC,UAAI,MAAEb,UAAE,MAAEc,UAAE,QAAEC,UAAI,OAAEC,UAAG,GAAG;AAShF,SAAU,QAAQ,CAAC,QAAgB,EAAE,OAAwB,EAAA;AAC/D,IAAA,MAAM,SAAS,GAAG,UAAU,CAAC,QAAQ,CAAC;IAEtC,IAAI,CAAC,SAAS,EAAE;AACZ,QAAA,MAAM,IAAI,KAAK,CAAC,oFAAoF,CAAC;IACzG;IAEA,IAAI,CAACjB,aAAE,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;QAChC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,MAAM,EAAE,WAAW,CAAC;AACpD,QAAAA,aAAE,CAAC,SAAS,CAAC,OAAO,CAAC,MAAM,CAAC;IAChC;AAEA;;AAEG;AACH,IAAA,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;AAAE,QAAA,OAAO,CAAC,SAAS,GAAG,MAAM;IAAE;;AAGtD,IAAA,OAAO,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,KAAI;AAC9C,QAAA,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;AACnB,YAAA,GAAG,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,IAAI,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;QACrG;aAAO;AACH,YAAA,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC;QACjB;AACA,QAAA,OAAO,GAAG;IACd,CAAC,EAAE,EAAE,CAAC;AAEN,IAAA,MAAM,UAAU,GAAG,UAAU,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,SAAS,CAAC;;AAG/D,IAAA,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;IAE3D,MAAM,KAAK,GAAG,SAAS,CAAC,UAAU,EAAE,OAAO,CAAC;AAE5C,IAAA,KAAK,CAAC,OAAO,CAAC,CAAC,IAAU,KAAI;AACzB,QAAA,MAAM,UAAU,GAAGD,eAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC;QAC1DC,aAAE,CAAC,aAAa,CAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC;QAC1C,OAAO,CAAC,GAAG,CAAC,YAAY,EAAE,IAAI,CAAC,IAAI,CAAC;AACxC,IAAA,CAAC,CAAC;AACN;AAEA,SAAS,cAAc,CAAC,GAAW,EAAA;AAC/B,IAAA,MAAM,KAAK,GAAGA,aAAE,CAAC,WAAW,CAAC,GAAG,EAAE,EAAE,aAAa,EAAE,IAAI,EAAE,CAAC;IAC1D,IAAI,OAAO,GAAa,EAAE;AAC1B,IAAA,KAAK,CAAC,OAAO,CAAC,IAAI,IAAG;AACjB,QAAA,MAAM,QAAQ,GAAGD,eAAI,CAAC,OAAO,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC;QAC7C,IAAI,CAAC,WAAW,EAAE,GAAG,OAAO,CAAC,IAAI,CAAC,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;AAC3F,IAAA,CAAC,CAAC;AACF,IAAA,OAAO,OAAO;AAClB;;ACtEA,MAAM,gBAAgB,GAA2B;AAC7C,IAAA,MAAM,EAAE,uBAAuB;AAC/B,IAAA,GAAG,EAAE,kBAAkB;AACvB,IAAA,IAAI,EAAE,mBAAmB;AACzB,IAAA,EAAE,EAAE,yBAAyB;AAC7B,IAAA,EAAE,EAAE,yBAAyB;AAC7B,IAAA,IAAI,EAAE,mBAAmB;AACzB,IAAA,GAAG,EAAE,kBAAkB;CAC1B;AAED,SAAS,WAAW,GAAA;IAChB,OAAO,CAAC,GAAG,CAAC,CAAA;;;;;;;EAOd,MAAM;QACJ,IAAI,CAAC,gBAAgB,CAAC;AACtB,QAAA,GAAG,CAAC,CAAC,QAAQ,MACjB,CAAA,MAAA,EAAS,QAAQ,CAAA,EAAA,EAAK,gBAAgB,CAAC,QAAQ,CAAC,CAAA,CAAE,CAC7C,CAAC;QACF,IAAI,CAAC,IAAI,CAAC;;;;AAI+C,4DAAA,CAAA,CAAC;IAC1D,OAAO,CAAC,IAAI,EAAE;AAClB;AAEA,MAAM,IAAI,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AACxC,IAAI,IAAI,CAAC,IAAI,EAAE;AACX,IAAA,WAAW,EAAE;AACjB;AAEA,IAAI,QAAgB;AACpB,KAAK,IAAI,MAAM,IAAI,gBAAgB,EAAE;AACjC,IAAA,IAAI,IAAI,CAAC,MAAM,CAAC,EAAE;QACd,QAAQ,GAAG,MAAM;IACrB;AACJ;AAEA,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AACd,IAAA,OAAO,CAAC,KAAK,CAAC,8CAA8C,CAAC;AAC7D,IAAA,WAAW,EAAE;AACjB;AAEA,IAAI;AACA,IAAA,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,CAAC;IACnB,QAAQ,CAAC,QAAQ,EAAE;QACf,KAAK,EAAE,IAAI,CAAC,CAAC;QACb,SAAS,EAAE,IAAI,CAAC,SAAS;QACzB,MAAM,EAAE,IAAI,CAAC,MAAM;QACnB,SAAS,EAAE,IAAI,CAAC;AACnB,KAAA,CAAC;AAEN;AAAE,OAAO,CAAC,EAAE;AACR,IAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC;AACxB,IAAA,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC;AACtB,IAAA,WAAW,EAAE;AACjB;;"}