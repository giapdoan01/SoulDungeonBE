#!/usr/bin/env node
'use strict';

var fs = require('fs');
var path = require('path');
var ts = require('typescript');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var fs__namespace = /*#__PURE__*/_interopNamespaceDefault(fs);
var path__namespace = /*#__PURE__*/_interopNamespaceDefault(path);
var ts__namespace = /*#__PURE__*/_interopNamespaceDefault(ts);

/**
 * @author Ethan Davis
 * https://github.com/ethanent/gar
 */
var argv = (sargs) => {
    let props = {};
    let lones = [];
    const convertIfApplicable = (value) => (isNaN(value) ? (value.toString().toLowerCase() === 'true' ? true : (value.toString().toLowerCase() === 'false' ? false : value)) : Number(value));
    const removeStartHyphens = (value) => value.replace(/^\-+/g, '');
    for (let i = 0; i < sargs.length; i++) {
        const equalsIndex = sargs[i].indexOf('=');
        const isNextRefProp = sargs[i].charAt(0) === '-' && sargs.length - 1 >= i + 1 && sargs[i + 1].indexOf('=') === -1 && sargs[i + 1].charAt(0) !== '-';
        const argName = equalsIndex === -1 ? removeStartHyphens(sargs[i]) : removeStartHyphens(sargs[i].slice(0, equalsIndex));
        if (equalsIndex !== -1) {
            props[argName] = convertIfApplicable(sargs[i].slice(equalsIndex + 1));
        }
        else if (isNextRefProp) {
            props[argName] = convertIfApplicable(sargs[i + 1]);
            i++;
        }
        else if (sargs[i].charAt(0) === '-') {
            if (sargs[i].charAt(1) === '-') {
                props[argName] = true;
            }
            else {
                for (let b = 0; b < argName.length; b++) {
                    props[argName.charAt(b)] = true;
                }
            }
        }
        else {
            lones.push(convertIfApplicable(argName));
        }
    }
    return Object.assign(props, {
        '_': lones
    });
};

if (typeof (__dirname) === "undefined") {
    global.__dirname = path__namespace.dirname(new URL((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.tagName.toUpperCase() === 'SCRIPT' && _documentCurrentScript.src || new URL('cli.cjs', document.baseURI).href))).pathname);
}
const VERSION = JSON.parse(fs__namespace.readFileSync(__dirname + "/../../package.json").toString()).version;
const COMMENT_HEADER = `
THIS FILE HAS BEEN GENERATED AUTOMATICALLY
DO NOT CHANGE IT MANUALLY UNLESS YOU KNOW WHAT YOU'RE DOING

GENERATED USING @colyseus/schema ${VERSION}
`;
function getCommentHeader(singleLineComment = "//") {
    return `${COMMENT_HEADER.split("\n").map(line => `${singleLineComment} ${line}`).join("\n")}`;
}
class Context {
    classes = [];
    interfaces = [];
    enums = [];
    getStructures() {
        return {
            classes: this.classes.filter(klass => {
                if (this.isSchemaClass(klass)) {
                    return true;
                }
                else {
                    let parentClass = klass;
                    while (parentClass = this.getParentClass(parentClass)) {
                        if (this.isSchemaClass(parentClass)) {
                            return true;
                        }
                    }
                }
                return false;
            }),
            interfaces: this.interfaces,
            enums: this.enums,
        };
    }
    addStructure(structure) {
        if (structure.context === this) {
            return;
        } // skip if already added.
        structure.context = this;
        if (structure instanceof Class) {
            this.classes.push(structure);
        }
        else if (structure instanceof Interface) {
            this.interfaces.push(structure);
        }
        else if (structure instanceof Enum) {
            this.enums.push(structure);
        }
    }
    getParentClass(klass) {
        return this.classes.find(c => c.name === klass.extends);
    }
    isSchemaClass(klass) {
        let isSchema = false;
        let currentClass = klass;
        while (!isSchema && currentClass) {
            //
            // TODO: ideally we should check for actual @colyseus/schema module
            // reference rather than arbitrary strings.
            //
            isSchema = (currentClass.extends === "Schema" ||
                currentClass.extends === "schema.Schema" ||
                currentClass.extends === "Schema.Schema");
            //
            // When extending from `schema.Schema`, it is required to
            // normalize as "Schema" for code generation.
            //
            if (currentClass === klass && isSchema) {
                klass.extends = "Schema";
            }
            currentClass = this.getParentClass(currentClass);
        }
        return isSchema;
    }
}
class Interface {
    context;
    name;
    properties = [];
    addProperty(property) {
        if (property.type.indexOf("[]") >= 0) {
            // is array!
            property.childType = property.type.match(/([^\[]+)/i)[1];
            property.type = "array";
            this.properties.push(property);
        }
        else {
            this.properties.push(property);
        }
    }
}
class Class {
    context;
    name;
    properties = [];
    extends;
    addProperty(property) {
        property.index = this.properties.length;
        this.properties.push(property);
    }
    postProcessing() {
        /**
         * Ensure the proprierties `index` are correct using inheritance
         */
        let parentKlass = this;
        while (parentKlass &&
            (parentKlass = this.context.classes.find(k => k.name === parentKlass.extends))) {
            this.properties.forEach(prop => {
                prop.index += parentKlass.properties.length;
            });
        }
    }
}
class Enum {
    context;
    name;
    properties = [];
    addProperty(property) {
        this.properties.push(property);
    }
}
class Property {
    index;
    name;
    type;
    childType;
    deprecated;
}
function getInheritanceTree(klass, allClasses, includeSelf = true) {
    let currentClass = klass;
    let inheritanceTree = [];
    if (includeSelf) {
        inheritanceTree.push(currentClass);
    }
    while (currentClass.extends !== "Schema") {
        currentClass = allClasses.find(klass => klass.name == currentClass.extends);
        inheritanceTree.push(currentClass);
    }
    return inheritanceTree;
}

let currentStructure;
let currentProperty;
let globalContext;
function defineProperty(property, initializer) {
    if (ts__namespace.isIdentifier(initializer)) {
        property.type = "ref";
        property.childType = initializer.text;
    }
    else if (initializer.kind == ts__namespace.SyntaxKind.ObjectLiteralExpression) {
        property.type = initializer.properties[0].name.text;
        property.childType = initializer.properties[0].initializer.text;
    }
    else if (initializer.kind == ts__namespace.SyntaxKind.ArrayLiteralExpression) {
        property.type = "array";
        property.childType = initializer.elements[0].text;
    }
    else {
        property.type = initializer.text;
    }
}
function inspectNode(node, context, decoratorName) {
    switch (node.kind) {
        case ts__namespace.SyntaxKind.ImportClause:
            const specifier = node.parent.moduleSpecifier;
            if (specifier && specifier.text.startsWith('.')) {
                const currentDir = path__namespace.dirname(node.getSourceFile().fileName);
                const pathToImport = path__namespace.resolve(currentDir, specifier.text);
                parseFiles([pathToImport], decoratorName, globalContext);
            }
            break;
        case ts__namespace.SyntaxKind.ClassDeclaration:
            currentStructure = new Class();
            const heritageClauses = node.heritageClauses;
            if (heritageClauses && heritageClauses.length > 0) {
                currentStructure.extends = heritageClauses[0].types[0].expression.getText();
            }
            context.addStructure(currentStructure);
            break;
        case ts__namespace.SyntaxKind.InterfaceDeclaration:
            //
            // Only generate Interfaces if it has "Message" on its name.
            // Example: MyMessage
            //
            const interfaceName = node.name.escapedText.toString();
            if (interfaceName.indexOf("Message") !== -1) {
                currentStructure = new Interface();
                currentStructure.name = interfaceName;
                context.addStructure(currentStructure);
            }
            break;
        case ts__namespace.SyntaxKind.EnumDeclaration:
            const enumName = node.name.escapedText.toString();
            currentStructure = new Enum();
            currentStructure.name = enumName;
            context.addStructure(currentStructure);
            break;
        case ts__namespace.SyntaxKind.ExtendsKeyword:
            // console.log(node.getText());
            break;
        case ts__namespace.SyntaxKind.PropertySignature:
            if (currentStructure instanceof Interface) {
                const interfaceDeclaration = node.parent;
                if (currentStructure.name !== interfaceDeclaration.name.escapedText.toString()) {
                    // skip if property if for a another interface than the one we're interested in.
                    break;
                }
                // define a property of an interface
                const property = new Property();
                property.name = node.name.escapedText.toString();
                property.type = node.type.getText();
                currentStructure.addProperty(property);
            }
            break;
        case ts__namespace.SyntaxKind.Identifier:
            if (node.getText() === "deprecated" &&
                node.parent.kind !== ts__namespace.SyntaxKind.ImportSpecifier) {
                currentProperty = new Property();
                currentProperty.deprecated = true;
                break;
            }
            if (node.getText() === decoratorName) {
                const prop = node.parent?.parent?.parent;
                const propDecorator = getDecorators(prop);
                const hasExpression = prop?.expression?.arguments;
                const hasDecorator = (propDecorator?.length > 0);
                /**
                 * neither a `@type()` decorator or `type()` call. skip.
                 */
                if (!hasDecorator && !hasExpression) {
                    break;
                }
                // using as decorator
                if (propDecorator) {
                    /**
                     * Calling `@type()` as decorator
                     */
                    const typeDecorator = propDecorator.find((decorator => {
                        return decorator.expression.expression.escapedText === decoratorName;
                    })).expression;
                    const property = currentProperty || new Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    const typeArgument = typeDecorator.arguments[0];
                    defineProperty(property, typeArgument);
                }
                else if (prop.expression.arguments?.[1] &&
                    prop.expression.expression.arguments?.[0]) {
                    /**
                     * Calling `type()` as a regular method
                     */
                    const property = currentProperty || new Property();
                    property.name = prop.expression.arguments[1].text;
                    currentStructure.addProperty(property);
                    const typeArgument = prop.expression.expression.arguments[0];
                    defineProperty(property, typeArgument);
                }
            }
            else if (node.getText() === "setFields" &&
                (node.parent.kind === ts__namespace.SyntaxKind.CallExpression ||
                    node.parent.kind === ts__namespace.SyntaxKind.PropertyAccessExpression)) {
                /**
                 * Metadata.setFields(klassName, { ... })
                 */
                const callExpression = (node.parent.kind === ts__namespace.SyntaxKind.PropertyAccessExpression)
                    ? node.parent.parent
                    : node.parent;
                /**
                 * Skip if @codegen-ignore comment is found before the call expression
                 * TODO: currently, if @codegen-ignore is on the file, it will skip all the setFields calls.
                 */
                const sourceFile = node.getSourceFile();
                const fullText = sourceFile.getFullText();
                const nodeStart = callExpression.getFullStart();
                const textBeforeNode = fullText.substring(0, nodeStart);
                if (textBeforeNode.includes('@codegen-ignore')) {
                    break;
                }
                if (callExpression.kind !== ts__namespace.SyntaxKind.CallExpression) {
                    break;
                }
                const classNameNode = callExpression.arguments[0];
                const className = ts__namespace.isClassExpression(classNameNode)
                    ? classNameNode.name?.escapedText.toString()
                    : classNameNode.getText();
                // skip if no className is provided
                if (!className) {
                    break;
                }
                if (currentStructure?.name !== className) {
                    currentStructure = new Class();
                }
                context.addStructure(currentStructure);
                currentStructure.extends = "Schema"; // force extends to Schema
                currentStructure.name = className;
                const types = callExpression.arguments[1];
                for (let i = 0; i < types.properties.length; i++) {
                    const prop = types.properties[i];
                    const property = currentProperty || new Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            else if (node.getText() === "defineTypes" &&
                (node.parent.kind === ts__namespace.SyntaxKind.CallExpression ||
                    node.parent.kind === ts__namespace.SyntaxKind.PropertyAccessExpression)) {
                /**
                 * JavaScript source file (`.js`)
                 * Using `defineTypes()`
                 */
                const callExpression = (node.parent.kind === ts__namespace.SyntaxKind.PropertyAccessExpression)
                    ? node.parent.parent
                    : node.parent;
                if (callExpression.kind !== ts__namespace.SyntaxKind.CallExpression) {
                    break;
                }
                const className = callExpression.arguments[0].getText();
                currentStructure.name = className;
                const types = callExpression.arguments[1];
                for (let i = 0; i < types.properties.length; i++) {
                    const prop = types.properties[i];
                    const property = currentProperty || new Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            if (node.parent.kind === ts__namespace.SyntaxKind.ClassDeclaration) {
                currentStructure.name = node.getText();
            }
            currentProperty = undefined;
            break;
        case ts__namespace.SyntaxKind.CallExpression:
            /**
             * Defining schema via `schema.schema({ ... })`
             * - schema.schema({})
             * - schema({})
             * - ClassName.extends({})
             */
            if (((node.expression?.getText() === "schema.schema" ||
                node.expression?.getText() === "schema") ||
                (node.expression?.getText().indexOf(".extends") !== -1)) &&
                node.arguments[0].kind === ts__namespace.SyntaxKind.ObjectLiteralExpression) {
                const callExpression = node;
                let className = callExpression.arguments[1]?.getText();
                if (!className && callExpression.parent.kind === ts__namespace.SyntaxKind.VariableDeclaration) {
                    className = callExpression.parent.name?.getText();
                }
                // skip if no className is provided
                if (!className) {
                    break;
                }
                if (currentStructure?.name !== className) {
                    currentStructure = new Class();
                    context.addStructure(currentStructure);
                }
                if (node.expression?.getText().indexOf(".extends") !== -1) {
                    // if it's using `.extends({})`
                    const extendsClass = node.expression?.expression?.escapedText;
                    // skip if no extendsClass is provided
                    if (!extendsClass) {
                        break;
                    }
                    currentStructure.extends = extendsClass;
                }
                else {
                    // if it's using `schema({})`
                    currentStructure.extends = "Schema"; // force extends to Schema
                }
                currentStructure.name = className;
                const types = callExpression.arguments[0];
                for (let i = 0; i < types.properties.length; i++) {
                    const prop = types.properties[i];
                    const property = currentProperty || new Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            break;
        case ts__namespace.SyntaxKind.EnumMember:
            if (currentStructure instanceof Enum) {
                const initializer = node.initializer?.text;
                const name = node.getFirstToken().getText();
                const property = currentProperty || new Property();
                property.name = name;
                if (initializer !== undefined) {
                    property.type = initializer;
                }
                currentStructure.addProperty(property);
                currentProperty = undefined;
            }
            break;
    }
    ts__namespace.forEachChild(node, (n) => inspectNode(n, context, decoratorName));
}
let parsedFiles;
function parseFiles(fileNames, decoratorName = "type", context = new Context()) {
    /**
     * Re-set globalContext for each test case
     */
    if (globalContext !== context) {
        parsedFiles = {};
        globalContext = context;
    }
    fileNames.forEach((fileName) => {
        let sourceFile;
        let sourceFileName;
        const fileNameAlternatives = [];
        if (!fileName.endsWith(".ts") &&
            !fileName.endsWith(".js") &&
            !fileName.endsWith(".mjs")) {
            fileNameAlternatives.push(`${fileName}.ts`);
            fileNameAlternatives.push(`${fileName}/index.ts`);
        }
        else if (fileName.endsWith(".js")) {
            // Handle .js extensions by also trying .ts (ESM imports often use .js extension)
            fileNameAlternatives.push(fileName);
            fileNameAlternatives.push(fileName.replace(/\.js$/, ".ts"));
        }
        else {
            fileNameAlternatives.push(fileName);
        }
        for (let i = 0; i < fileNameAlternatives.length; i++) {
            try {
                sourceFileName = path__namespace.resolve(fileNameAlternatives[i]);
                if (parsedFiles[sourceFileName]) {
                    break;
                }
                sourceFile = ts__namespace.createSourceFile(sourceFileName, fs.readFileSync(sourceFileName).toString(), ts__namespace.ScriptTarget.Latest, true);
                parsedFiles[sourceFileName] = true;
                break;
            }
            catch (e) {
                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);
            }
        }
        if (sourceFile) {
            inspectNode(sourceFile, context, decoratorName);
        }
    });
    return context.getStructures();
}
/**
 * TypeScript 4.8+ has introduced a change on how to access decorators.
 * - https://github.com/microsoft/TypeScript/pull/49089
 * - https://devblogs.microsoft.com/typescript/announcing-typescript-4-8/#decorators-are-placed-on-modifiers-on-typescripts-syntax-trees
 */
function getDecorators(node) {
    if (node == undefined) {
        return undefined;
    }
    // TypeScript 4.7 and below
    // @ts-ignore
    if (node.decorators) {
        return node.decorators;
    }
    // TypeScript 4.8 and above
    // @ts-ignore
    if (ts__namespace.canHaveDecorators && ts__namespace.canHaveDecorators(node)) {
        // @ts-ignore
        const decorators = ts__namespace.getDecorators(node);
        return decorators ? Array.from(decorators) : undefined;
    }
    // @ts-ignore
    return node.modifiers?.filter(ts__namespace.isDecorator);
}

const typeMaps$6 = {
    "string": "string",
    "number": "float",
    "boolean": "bool",
    "int8": "sbyte",
    "uint8": "byte",
    "int16": "short",
    "uint16": "ushort",
    "int32": "int",
    "uint32": "uint",
    "int64": "long",
    "uint64": "ulong",
    "float32": "float",
    "float64": "double",
};
/**
 * C# Code Generator
 */
const capitalize$1 = (s) => {
    if (typeof s !== 'string')
        return '';
    return s.charAt(0).toUpperCase() + s.slice(1);
};
function generate$7(context, options) {
    // enrich typeMaps with enums
    context.enums.forEach((structure) => {
        typeMaps$6[structure.name] = structure.name;
    });
    return [
        ...context.classes.map(structure => ({
            name: `${structure.name}.cs`,
            content: generateClass$6(structure, options.namespace)
        })),
        ...context.interfaces.map(structure => ({
            name: `${structure.name}.cs`,
            content: generateInterface$1(structure, options.namespace),
        })),
        ...context.enums.filter(structure => structure.name !== 'OPERATION').map((structure) => ({
            name: `${structure.name}.cs`,
            content: generateEnum(structure, options.namespace),
        })),
    ];
}
function generateClass$6(klass, namespace) {
    const indent = (namespace) ? "\t" : "";
    return `${getCommentHeader()}

using Colyseus.Schema;
#if UNITY_5_3_OR_NEWER
using UnityEngine.Scripting;
#endif
${namespace ? `\nnamespace ${namespace} {` : ""}
${indent}public partial class ${klass.name} : ${klass.extends} {
#if UNITY_5_3_OR_NEWER
[Preserve]
#endif
public ${klass.name}() { }
${klass.properties.map((prop) => generateProperty$4(prop, indent)).join("\n\n")}
${indent}}
${namespace ? "}" : ""}
`;
}
function generateEnum(_enum, namespace) {
    const indent = namespace ? "\t" : "";
    return `${getCommentHeader()}
${namespace ? `\nnamespace ${namespace} {` : ""}
${indent}public struct ${_enum.name} {

${_enum.properties
        .map((prop) => {
        let dataType = "int";
        let value;
        if (prop.type) {
            if (isNaN(Number(prop.type))) {
                value = `"${prop.type}"`;
                dataType = "string";
            }
            else {
                value = Number(prop.type);
                dataType = Number.isInteger(value) ? 'int' : 'float';
            }
        }
        else {
            value = _enum.properties.indexOf(prop);
        }
        return `${indent}\tpublic const ${dataType} ${prop.name} = ${value};`;
    })
        .join("\n")}
${indent}}
${namespace ? "}" : ""}`;
}
function generateProperty$4(prop, indent = "") {
    let typeArgs = `"${prop.type}"`;
    let property = "public";
    let langType;
    let initializer = "";
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        langType = getType(prop);
        typeArgs += `, typeof(${langType})`;
        if (!isUpcaseFirst) {
            typeArgs += `, "${prop.childType}"`;
        }
        initializer = `null`;
    }
    else {
        langType = getType(prop);
        initializer = `default(${langType})`;
    }
    property += ` ${langType} ${prop.name}`;
    let ret = (prop.deprecated) ? `\t\t[System.Obsolete("field '${prop.name}' is deprecated.", true)]\n` : '';
    return ret + `\t${indent}[Type(${prop.index}, ${typeArgs})]
\t${indent}${property} = ${initializer};`;
}
function generateInterface$1(struct, namespace) {
    const indent = (namespace) ? "\t" : "";
    return `${getCommentHeader()}

using Colyseus.Schema;
${namespace ? `\nnamespace ${namespace} {` : ""}
${indent}public class ${struct.name} {
${struct.properties.map(prop => `\t${indent}public ${getType(prop)} ${prop.name};`).join("\n")}
${indent}}
${namespace ? "}" : ""}
`;
}
function getChildType(prop) {
    return typeMaps$6[prop.childType];
}
function getType(prop) {
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        let type;
        if (prop.type === "ref") {
            type = (isUpcaseFirst)
                ? prop.childType
                : getChildType(prop);
        }
        else {
            const containerClass = capitalize$1(prop.type);
            type = (isUpcaseFirst)
                ? `${containerClass}Schema<${prop.childType}>`
                : `${containerClass}Schema<${getChildType(prop)}>`;
        }
        return type;
    }
    else {
        return (prop.type === "array")
            ? `${typeMaps$6[prop.childType] || prop.childType}[]`
            : typeMaps$6[prop.type];
    }
}

const typeMaps$5 = {
    "string": "string",
    "number": "varint_t",
    "boolean": "bool",
    "int8": "int8_t",
    "uint8": "uint8_t",
    "int16": "int16_t",
    "uint16": "uint16_t",
    "int32": "int32_t",
    "uint32": "uint32_t",
    "int64": "int64_t",
    "uint64": "uint64_t",
    "float32": "float32_t",
    "float64": "float64_t",
};
const typeInitializer$2 = {
    "string": '""',
    "number": "0",
    "boolean": "false",
    "int8": "0",
    "uint8": "0",
    "int16": "0",
    "uint16": "0",
    "int32": "0",
    "uint32": "0",
    "int64": "0",
    "uint64": "0",
    "float32": "0",
    "float64": "0",
};
/**
 * C++ Code Generator
 */
const capitalize = (s) => {
    if (typeof s !== 'string')
        return '';
    return s.charAt(0).toUpperCase() + s.slice(1);
};
const distinct$3 = (value, index, self) => self.indexOf(value) === index;
function generate$6(context, options) {
    return context.classes.map(klass => ({
        name: klass.name + ".hpp",
        content: generateClass$5(klass, options.namespace, context.classes)
    }));
}
function generateClass$5(klass, namespace, allClasses) {
    const propertiesPerType = {};
    const allRefs = [];
    klass.properties.forEach(property => {
        let type = property.type;
        if (!propertiesPerType[type]) {
            propertiesPerType[type] = [];
        }
        propertiesPerType[type].push(property);
        // keep all refs list
        if ((type === "ref" || type === "array" || type === "map")) {
            allRefs.push(property);
        }
    });
    const allProperties = getAllProperties(klass, allClasses);
    const createInstanceMethod = (allRefs.length === 0) ? "" :
        `\tinline Schema* createInstance(std::type_index type) {
\t\t${generateFieldIfElseChain(allRefs, (property) => `type == typeid(${property.childType})`, (property) => `return new ${property.childType}();`, (property) => typeMaps$5[property.childType] === undefined)}
\t\treturn ${klass.extends}::createInstance(type);
\t}`;
    return `${getCommentHeader()}
#ifndef __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__
#define __SCHEMA_CODEGEN_${klass.name.toUpperCase()}_H__ 1

#include "schema.h"
#include <typeinfo>
#include <typeindex>

${allRefs.
        filter(ref => ref.childType && typeMaps$5[ref.childType] === undefined).
        map(ref => ref.childType).
        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).
        filter(distinct$3).
        map(childType => `#include "${childType}.hpp"`).
        join("\n")}

using namespace colyseus::schema;

${namespace ? `namespace ${namespace} {` : ""}
class ${klass.name} : public ${klass.extends} {
public:
${klass.properties.map(prop => generateProperty$3(prop)).join("\n")}

\t${klass.name}() {
\t\tthis->_indexes = ${generateAllIndexes(allProperties)};
\t\tthis->_types = ${generateAllTypes(allProperties)};
\t\tthis->_childPrimitiveTypes = ${generateAllChildPrimitiveTypes(allProperties)};
\t\tthis->_childSchemaTypes = ${generateAllChildSchemaTypes(allProperties)};
\t}

\tvirtual ~${klass.name}() {
\t\t${generateDestructors(allProperties).join("\n\t\t")}
\t}

protected:
${Object.keys(propertiesPerType).map(type => generateGettersAndSetters(klass, type, propertiesPerType[type])).
        join("\n")}

${createInstanceMethod}
};
${namespace ? "}" : ""}

#endif
`;
}
function generateProperty$3(prop) {
    let property = "";
    let langType;
    let initializer = "";
    let isPropPointer = "";
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (prop.type === "ref") {
            langType = `${prop.childType}`;
            initializer = `new ${prop.childType}()`;
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? `ArraySchema<${prop.childType}*>`
                : `ArraySchema<${typeMaps$5[prop.childType]}>`;
            initializer = `new ${langType}()`;
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? `MapSchema<${prop.childType}*>`
                : `MapSchema<${typeMaps$5[prop.childType]}>`;
            initializer = `new ${langType}()`;
        }
        isPropPointer = "*";
    }
    else {
        langType = typeMaps$5[prop.type];
        initializer = typeInitializer$2[prop.type];
    }
    property += ` ${langType} ${isPropPointer}${prop.name}`;
    return `\t${property} = ${initializer};`;
}
function generateGettersAndSetters(klass, type, properties) {
    let langType = typeMaps$5[type];
    let typeCast = "";
    const getMethodName = `get${capitalize(type)}`;
    const setMethodName = `set${capitalize(type)}`;
    if (type === "ref") {
        langType = "Schema*";
    }
    else if (type === "array") {
        langType = `ArraySchema<char*> *`;
        typeCast = `(ArraySchema<char*> *)`;
    }
    else if (type === "map") {
        langType = `MapSchema<char*> *`;
        typeCast = `(MapSchema<char*> *)`;
    }
    return `\tinline ${langType} ${getMethodName}(const string &field)
\t{
\t\t${generateFieldIfElseChain(properties, (property) => `field == "${property.name}"`, (property) => `return ${typeCast}this->${property.name};`)}
\t\treturn ${klass.extends}::${getMethodName}(field);
\t}

\tinline void ${setMethodName}(const string &field, ${langType} value)
\t{
\t\t${generateFieldIfElseChain(properties, (property) => `field == "${property.name}"`, (property) => {
        const isSchemaType = (typeMaps$5[property.childType] === undefined);
        if (type === "ref") {
            langType = `${property.childType}*`;
            typeCast = (isSchemaType)
                ? `(${property.childType}*)`
                : `/* bug? */`;
        }
        else if (type === "array") {
            typeCast = (isSchemaType)
                ? `(ArraySchema<${property.childType}*> *)`
                : `(ArraySchema<${typeMaps$5[property.childType]}> *)`;
        }
        else if (type === "map") {
            typeCast = (isSchemaType)
                ? `(MapSchema<${property.childType}*> *)`
                : `(MapSchema<${typeMaps$5[property.childType]}> *)`;
        }
        return `this->${property.name} = ${typeCast}value;\n\t\t\treturn;`;
    })}
\t\treturn ${klass.extends}::${setMethodName}(field, value);
\t}`;
}
function generateFieldIfElseChain(properties, ifCallback, callback, filter = (_) => true) {
    let chain = "";
    const uniqueChecks = [];
    properties.filter(filter).forEach((property, i) => {
        const check = ifCallback(property);
        if (uniqueChecks.indexOf(check) === -1) {
            uniqueChecks.push(check);
        }
        else {
            return;
        }
        if (i === 0) {
            chain += "if ";
        }
        else {
            chain += " else if ";
        }
        chain += `(${check})
\t\t{
\t\t\t${callback(property)}\n
\t\t}`;
    });
    return chain;
}
function generateAllIndexes(properties) {
    return `{${properties.map((property, i) => `{${i}, "${property.name}"}`).join(", ")}}`;
}
function generateAllTypes(properties) {
    return `{${properties.map((property, i) => `{${i}, "${property.type}"}`).join(", ")}}`;
}
function generateAllChildSchemaTypes(properties) {
    return `{${properties.map((property, i) => {
        if (property.childType && typeMaps$5[property.childType] === undefined) {
            return `{${i}, typeid(${property.childType})}`;
        }
        else {
            return null;
        }
    }).filter(r => r !== null).join(", ")}}`;
}
function generateAllChildPrimitiveTypes(properties) {
    return `{${properties.map((property, i) => {
        if (typeMaps$5[property.childType] !== undefined) {
            return `{${i}, "${property.childType}"}`;
        }
        else {
            return null;
        }
    }).filter(r => r !== null).join(", ")}}`;
}
function generateDestructors(properties) {
    return properties.map((property, i) => {
        if (property.childType) {
            return `delete this->${property.name};`;
        }
        else {
            return null;
        }
    }).filter(r => r !== null);
}
function getAllProperties(klass, allClasses) {
    let properties = [];
    getInheritanceTree(klass, allClasses).reverse().forEach((klass) => {
        properties = properties.concat(klass.properties);
    });
    return properties;
}

const typeMaps$4 = {
    "string": "String",
    "number": "Dynamic",
    "boolean": "Bool",
    "int8": "Int",
    "uint8": "UInt",
    "int16": "Int",
    "uint16": "UInt",
    "int32": "Int",
    "uint32": "UInt",
    "int64": "Int",
    "uint64": "UInt",
    "float32": "Float",
    "float64": "Float",
};
const typeInitializer$1 = {
    "string": '""',
    "number": "0",
    "boolean": "false",
    "int8": "0",
    "uint8": "0",
    "int16": "0",
    "uint16": "0",
    "int32": "0",
    "uint32": "0",
    "int64": "0",
    "uint64": "0",
    "float32": "0",
    "float64": "0",
};
function generate$5(context, options) {
    return context.classes.map(klass => ({
        name: klass.name + ".hx",
        content: generateClass$4(klass, options.namespace, context.classes)
    }));
}
function generateClass$4(klass, namespace, allClasses) {
    return `${getCommentHeader()}

${namespace ? `package ${namespace};` : ""}
import io.colyseus.serializer.schema.Schema;
import io.colyseus.serializer.schema.types.*;

class ${klass.name} extends ${klass.extends} {
${klass.properties.map(prop => generateProperty$2(prop)).join("\n")}
}
`;
}
function generateProperty$2(prop) {
    let langType;
    let initializer = "";
    let typeArgs = `"${prop.type}"`;
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (isUpcaseFirst) {
            typeArgs += `, ${prop.childType}`;
        }
        else {
            typeArgs += `, "${prop.childType}"`;
        }
        if (prop.type === "ref") {
            langType = `${prop.childType}`;
            initializer = `new ${prop.childType}()`;
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? `ArraySchema<${prop.childType}>`
                : `ArraySchema<${typeMaps$4[prop.childType]}>`;
            initializer = `new ${langType}()`;
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? `MapSchema<${prop.childType}>`
                : `MapSchema<${typeMaps$4[prop.childType]}>`;
            initializer = `new ${langType}()`;
        }
    }
    else {
        langType = typeMaps$4[prop.type];
        initializer = typeInitializer$1[prop.type];
    }
    // TODO: remove initializer. The callbacks at the Haxe decoder side have a
    // "FIXME" comment about this on Decoder.hx
    return `\t@:type(${typeArgs})\n\tpublic var ${prop.name}: ${langType} = ${initializer};\n`;
    // return `\t@:type(${typeArgs})\n\tpublic var ${prop.name}: ${langType};\n`
}

const typeMaps$3 = {
    "string": "string",
    "number": "number",
    "boolean": "boolean",
    "int8": "number",
    "uint8": "number",
    "int16": "number",
    "uint16": "number",
    "int32": "number",
    "uint32": "number",
    "int64": "number",
    "uint64": "number",
    "float32": "number",
    "float64": "number",
};
const distinct$2 = (value, index, self) => self.indexOf(value) === index;
function generate$4(context, options) {
    return [
        ...context.classes.map(structure => ({
            name: structure.name + ".ts",
            content: generateClass$3(structure, options.namespace, context.classes)
        })),
        ...context.interfaces.map(structure => ({
            name: structure.name + ".ts",
            content: generateInterface(structure, options.namespace, context.classes),
        }))
    ];
}
function generateClass$3(klass, namespace, allClasses) {
    const allRefs = [];
    klass.properties.forEach(property => {
        let type = property.type;
        // keep all refs list
        if ((type === "ref" || type === "array" || type === "map" || type === "set")) {
            allRefs.push(property);
        }
    });
    return `${getCommentHeader()}

import { Schema, type, ArraySchema, MapSchema, SetSchema, DataChange } from '@colyseus/schema';
${allRefs.
        filter(ref => ref.childType && typeMaps$3[ref.childType] === undefined).
        map(ref => ref.childType).
        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).
        filter(distinct$2).
        map(childType => `import { ${childType} } from './${childType}'`).
        join("\n")}

export class ${klass.name} extends ${klass.extends} {
${klass.properties.map(prop => `    ${generateProperty$1(prop)}`).join("\n")}
}
`;
}
function generateProperty$1(prop) {
    let langType;
    let initializer = "";
    let typeArgs;
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (isUpcaseFirst) {
            typeArgs += `, ${prop.childType}`;
        }
        else {
            typeArgs += `, "${prop.childType}"`;
        }
        if (prop.type === "ref") {
            langType = `${prop.childType}`;
            initializer = `new ${prop.childType}()`;
            typeArgs = `${prop.childType}`;
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? `ArraySchema<${prop.childType}>`
                : `ArraySchema<${typeMaps$3[prop.childType]}>`;
            initializer = `new ${langType}()`;
            typeArgs = (isUpcaseFirst)
                ? `[ ${prop.childType} ]`
                : `[ "${prop.childType}" ]`;
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? `MapSchema<${prop.childType}>`
                : `MapSchema<${typeMaps$3[prop.childType]}>`;
            initializer = `new ${langType}()`;
            typeArgs = (isUpcaseFirst)
                ? `{ map: ${prop.childType} }`
                : `{ map: "${prop.childType}" }`;
        }
        else if (prop.type === "set") {
            langType = (isUpcaseFirst)
                ? `SetSchema<${prop.childType}>`
                : `SetSchema<${typeMaps$3[prop.childType]}>`;
            initializer = `new ${langType}()`;
            typeArgs = (isUpcaseFirst)
                ? `{ set: ${prop.childType} }`
                : `{ set: "${prop.childType}" }`;
        }
    }
    else {
        langType = typeMaps$3[prop.type];
        typeArgs = `"${prop.type}"`;
    }
    // TS1263: "Declarations with initializers cannot also have definite assignment assertions"
    const definiteAssertion = initializer ? "" : "!";
    return `@type(${typeArgs}) public ${prop.name}${definiteAssertion}: ${langType}${(initializer) ? ` = ${initializer}` : ""};`;
}
function generateInterface(structure, namespace, allClasses) {
    return `${getCommentHeader()}

export interface ${structure.name} {
${structure.properties.map(prop => `    ${prop.name}: ${prop.type};`).join("\n")}
}
`;
}

const typeMaps$2 = {
    "string": "string",
    "number": "number",
    "boolean": "boolean",
    "int8": "number",
    "uint8": "number",
    "int16": "number",
    "uint16": "number",
    "int32": "number",
    "uint32": "number",
    "int64": "number",
    "uint64": "number",
    "float32": "number",
    "float64": "number",
};
const distinct$1 = (value, index, self) => self.indexOf(value) === index;
function generate$3(context, options) {
    return context.classes.map(klass => ({
        name: klass.name + ".js",
        content: generateClass$2(klass, options.namespace, context.classes)
    }));
}
function generateClass$2(klass, namespace, allClasses) {
    const allRefs = [];
    klass.properties.forEach(property => {
        let type = property.type;
        // keep all refs list
        if ((type === "ref" || type === "array" || type === "map")) {
            allRefs.push(property);
        }
    });
    return `${getCommentHeader()}

const schema = require("@colyseus/schema");
const Schema = schema.Schema;
const type = schema.type;
${allRefs.
        filter(ref => ref.childType && typeMaps$2[ref.childType] === undefined).
        map(ref => ref.childType).
        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).
        filter(distinct$1).
        map(childType => `const ${childType} = require("./${childType}");`).
        join("\n")}

class ${klass.name} extends ${klass.extends} {
    constructor () {
        super();
${klass.properties.
        filter(prop => prop.childType !== undefined).
        map(prop => "        " + generatePropertyInitializer(prop)).join("\n")}
    }
}
${klass.properties.map(prop => generatePropertyDeclaration$1(klass.name, prop)).join("\n")}

export default ${klass.name};
`;
}
function generatePropertyDeclaration$1(className, prop) {
    let typeArgs;
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (isUpcaseFirst) {
            typeArgs += `, ${prop.childType}`;
        }
        else {
            typeArgs += `, "${prop.childType}"`;
        }
        if (prop.type === "ref") {
            typeArgs = `${prop.childType}`;
        }
        else if (prop.type === "array") {
            typeArgs = (isUpcaseFirst)
                ? `[ ${prop.childType} ]`
                : `[ "${prop.childType}" ]`;
        }
        else if (prop.type === "map") {
            typeArgs = (isUpcaseFirst)
                ? `{ map: ${prop.childType} }`
                : `{ map: "${prop.childType}" }`;
        }
    }
    else {
        typeArgs = `"${prop.type}"`;
    }
    return `type(${typeArgs})(${className}.prototype, "${prop.name}");`;
}
function generatePropertyInitializer(prop) {
    let initializer = "";
    if (prop.type === "ref") {
        initializer = `new ${prop.childType}()`;
    }
    else if (prop.type === "array") {
        initializer = `new schema.ArraySchema()`;
    }
    else if (prop.type === "map") {
        initializer = `new schema.MapSchema()`;
    }
    return `this.${prop.name} = ${initializer}`;
}

const typeMaps$1 = {
    "string": "String",
    "number": "float",
    "boolean": "boolean",
    "int8": "byte",
    "uint8": "short",
    "int16": "short",
    "uint16": "int",
    "int32": "int",
    "uint32": "long",
    "int64": "long",
    "uint64": "long",
    "float32": "float",
    "float64": "double",
};
const typeInitializer = {
    "string": '""',
    "number": "0",
    "boolean": "false",
    "int8": "0",
    "uint8": "0",
    "int16": "0",
    "uint16": "0",
    "int32": "0",
    "uint32": "0",
    "int64": "0",
    "uint64": "0",
    "float32": "0",
    "float64": "0",
};
/**
 * C# Code Generator
 */
function generate$2(context, options) {
    return context.classes.map(klass => ({
        name: klass.name + ".java",
        content: generateClass$1(klass, options.namespace)
    }));
}
function generateClass$1(klass, namespace) {
    const indent = (namespace) ? "\t" : "";
    return `${getCommentHeader()}
${namespace ? `\npackage ${namespace};` : ""}

import io.colyseus.serializer.schema.Schema;
import io.colyseus.serializer.schema.annotations.SchemaClass;
import io.colyseus.serializer.schema.annotations.SchemaField;

@SchemaClass
${indent}public class ${klass.name} extends ${klass.extends} {
${klass.properties.map(prop => generateProperty(prop, indent)).join("\n\n")}
${indent}}
${namespace ? "}" : ""}
`;
}
function generateProperty(prop, indent = "") {
    let typeArgs = `${prop.index}/${prop.type}`;
    let property = "public";
    let langType;
    let ctorArgs = "";
    let initializer = "";
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (prop.type !== "ref" && isUpcaseFirst) {
            ctorArgs = `${prop.childType}.class`;
        }
        if (prop.type === "ref") {
            langType = (isUpcaseFirst)
                ? prop.childType
                : typeMaps$1[prop.childType];
            initializer = `new ${langType}${(prop.type !== "ref" && isUpcaseFirst) ? "<>" : ""}(${ctorArgs})`;
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? `ArraySchema<${prop.childType}>`
                : `ArraySchema`;
            initializer = `new ArraySchema${(isUpcaseFirst) ? "<>" : ""}(${ctorArgs})`;
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? `MapSchema<${prop.childType}>`
                : `MapSchema`;
            initializer = `new MapSchema${(isUpcaseFirst) ? "<>" : ""}(${ctorArgs})`;
        }
        if (prop.type !== "ref") {
            typeArgs += (isUpcaseFirst)
                ? `/ref`
                : `/${prop.childType}`;
        }
    }
    else {
        langType = typeMaps$1[prop.type];
        initializer = typeInitializer[prop.type];
    }
    property += ` ${langType} ${prop.name}`;
    return `\t@SchemaField("${typeArgs}")\t${indent}
\t${indent}${property} = ${initializer};`;
}

/**
    TODO:
    - Support inheritance
    - Support importing Schema dependencies
*/
const typeMaps = {
    "string": "string",
    "number": "number",
    "boolean": "boolean",
    "int8": "number",
    "uint8": "number",
    "int16": "number",
    "uint16": "number",
    "int32": "number",
    "uint32": "number",
    "int64": "number",
    "uint64": "number",
    "float32": "number",
    "float64": "number",
};
const distinct = (value, index, self) => self.indexOf(value) === index;
function generate$1(context, options) {
    return context.classes.map(klass => ({
        name: klass.name + ".lua",
        content: generateClass(klass, options.namespace, context.classes)
    }));
}
function generateClass(klass, namespace, allClasses) {
    const allRefs = [];
    klass.properties.forEach(property => {
        let type = property.type;
        // keep all refs list
        if ((type === "ref" || type === "array" || type === "map")) {
            allRefs.push(property);
        }
    });
    // Inheritance support
    const inherits = (klass.extends !== "Schema")
        ? `, ${klass.extends}`
        : "";
    return `${getCommentHeader().replace(/\/\//mg, "--")}

local schema = require 'colyseus.serializer.schema.schema'
${allRefs.
        filter(ref => ref.childType && typeMaps[ref.childType] === undefined).
        map(ref => ref.childType).
        concat(getInheritanceTree(klass, allClasses, false).map(klass => klass.name)).
        filter(distinct).
        map(childType => `local ${childType} = require '${(namespace ? `${namespace}.` : '')}${childType}'`).
        join("\n")}

---@class ${klass.name}: ${klass.extends}
${klass.properties.map(prop => `---@field ${prop.name} ${getLUATypeAnnotation(prop)}`).join("\n")}
local ${klass.name} = schema.define({
${klass.properties.map(prop => generatePropertyDeclaration(prop)).join(",\n")},
    ["_fields_by_index"] = { ${klass.properties.map(prop => `"${prop.name}"`).join(", ")} },
}${inherits})

return ${klass.name}
`;
}
function generatePropertyDeclaration(prop) {
    let typeArgs;
    if (prop.childType) {
        const isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (isUpcaseFirst) {
            typeArgs += `${prop.childType}`;
        }
        else {
            typeArgs += `"${prop.childType}"`;
        }
        if (prop.type === "ref") {
            typeArgs = (isUpcaseFirst)
                ? `${prop.childType}`
                : `"${prop.childType}"`;
        }
        else {
            typeArgs = (isUpcaseFirst)
                ? `{ ${prop.type} = ${prop.childType} }`
                : `{ ${prop.type} = "${prop.childType}" }`;
        }
    }
    else {
        typeArgs = `"${prop.type}"`;
    }
    return `    ["${prop.name}"] = ${typeArgs}`;
}
function getLUATypeAnnotation(prop) {
    if (prop.type === "ref") {
        return prop.childType;
    }
    else if (prop.type === "array") {
        return "ArraySchema";
    }
    else if (prop.type === "map") {
        return "MapSchema";
    }
    else {
        return typeMaps[prop.type];
    }
}

const generators = { csharp: generate$7, cpp: generate$6, haxe: generate$5, ts: generate$4, js: generate$3, java: generate$2, lua: generate$1, };
function generate(targetId, options) {
    const generator = generators[targetId];
    if (!generator) {
        throw new Error("You must provide a valid generator as argument, such as: --csharp, --haxe or --cpp");
    }
    if (!fs__namespace.existsSync(options.output)) {
        console.log("Creating", options.output, "directory");
        fs__namespace.mkdirSync(options.output);
    }
    /**
     * Default `@type()` decorator name
     */
    if (!options.decorator) {
        options.decorator = "type";
    }
    // resolve wildcard files
    options.files = options.files.reduce((acc, cur) => {
        if (cur.endsWith("*")) {
            acc.push(...recursiveFiles(cur.slice(0, -1)).filter(filename => /\.(js|ts|mjs)$/.test(filename)));
        }
        else {
            acc.push(cur);
        }
        return acc;
    }, []);
    const structures = parseFiles(options.files, options.decorator);
    // Post-process classes before generating
    structures.classes.forEach(klass => klass.postProcessing());
    const files = generator(structures, options);
    files.forEach((file) => {
        const outputPath = path__namespace.resolve(options.output, file.name);
        fs__namespace.writeFileSync(outputPath, file.content);
        console.log("generated:", file.name);
    });
}
function recursiveFiles(dir) {
    const files = fs__namespace.readdirSync(dir, { withFileTypes: true });
    let collect = [];
    files.forEach(file => {
        const filename = path__namespace.resolve(dir, file.name);
        file.isDirectory() ? collect.push(...recursiveFiles(filename)) : collect.push(filename);
    });
    return collect;
}

const supportedTargets = {
    csharp: 'generate for C#/Unity',
    cpp: 'generate for C++',
    haxe: 'generate for Haxe',
    ts: 'generate for TypeScript',
    js: 'generate for JavaScript',
    java: 'generate for Java',
    lua: 'generate for LUA',
};
function displayHelp() {
    console.log(`\nschema-codegen [path/to/Schema.ts]

Usage (C#/Unity)
    schema-codegen src/Schema.ts --output client-side/ --csharp --namespace MyGame.Schema

Valid options:
    --output: the output directory for generated client-side schema files
${Object.
        keys(supportedTargets).
        map((targetId) => (`    --${targetId}: ${supportedTargets[targetId]}`)).
        join("\n")}

Optional:
    --namespace: generate namespace on output code
    --decorator: custom name for @type decorator to scan for`);
    process.exit();
}
const args = argv(process.argv.slice(2));
if (args.help) {
    displayHelp();
}
let targetId;
for (let target in supportedTargets) {
    if (args[target]) {
        targetId = target;
    }
}
if (!args.output) {
    console.error("You must provide a valid --output directory.");
    displayHelp();
}
try {
    args.files = args._;
    generate(targetId, {
        files: args._,
        decorator: args.decorator,
        output: args.output,
        namespace: args.namespace
    });
}
catch (e) {
    console.error(e.message);
    console.error(e.stack);
    displayHelp();
}
//# sourceMappingURL=cli.cjs.map
