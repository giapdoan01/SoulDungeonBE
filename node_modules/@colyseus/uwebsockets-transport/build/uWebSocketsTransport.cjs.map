{
  "version": 3,
  "sources": ["../src/uWebSocketsTransport.ts"],
  "sourcesContent": ["import querystring, { type ParsedUrlQuery } from 'querystring';\nimport uWebSockets, { type WebSocket } from 'uWebSockets.js';\nimport type express from 'express';\n\nimport { type AuthContext, Transport, matchMaker, Protocol, getBearerToken, debugAndPrintError, spliceOne, connectClientToRoom, type Router } from '@colyseus/core';\nimport { uWebSocketClient, uWebSocketWrapper } from './uWebSocketClient.ts';\nimport { Deferred } from '@colyseus/core';\n\nconst uWebSocketsExpress = new Deferred<typeof import('uwebsockets-express')>;\nlet uWebSocketsExpressModule: typeof import('uwebsockets-express') | undefined = undefined;\nimport('uwebsockets-express')\n  .then((module) => uWebSocketsExpress.resolve(module))\n  .catch((error) => uWebSocketsExpress.reject(error));\n\nexport type TransportOptions = Omit<uWebSockets.WebSocketBehavior<any>, \"upgrade\" | \"open\" | \"pong\" | \"close\" | \"message\">;\n\ntype RawWebSocketClient = uWebSockets.WebSocket<any> & {\n  url: string,\n  searchParams: ParsedUrlQuery,\n  context: AuthContext,\n};\n\nexport class uWebSocketsTransport extends Transport {\n  public app: uWebSockets.TemplatedApp;\n\n  protected clients: RawWebSocketClient[] = [];\n  protected clientWrappers = new WeakMap<RawWebSocketClient, uWebSocketWrapper>();\n\n  private _listeningSocket: any;\n  private _originalRawSend: typeof uWebSocketClient.prototype.raw | null = null;\n  private _expressApp?: express.Application;\n\n  constructor(options: TransportOptions = {}, appOptions: uWebSockets.AppOptions = {}) {\n    super();\n\n    this.app = (appOptions.cert_file_name && appOptions.key_file_name)\n      ? uWebSockets.SSLApp(appOptions)\n      : uWebSockets.App(appOptions);\n\n    if (options.maxBackpressure === undefined) {\n      options.maxBackpressure = 1024 * 1024;\n    }\n\n    if (options.compression === undefined) {\n      options.compression = uWebSockets.DISABLED;\n    }\n\n    if (options.maxPayloadLength === undefined) {\n      options.maxPayloadLength = 4 * 1024;\n    }\n\n    if (options.sendPingsAutomatically === undefined) {\n      options.sendPingsAutomatically = true;\n    }\n\n    this.app.ws('/*', {\n      ...options,\n\n      upgrade: (res, req, context) => {\n        // get all headers\n        const headers: { [id: string]: string } = {};\n        req.forEach((key, value) => headers[key] = value);\n\n        const searchParams = querystring.parse(req.getQuery());\n\n        /* This immediately calls open handler, you must not use res after this call */\n        /* Spell these correctly */\n        res.upgrade(\n          {\n            url: req.getUrl(),\n            searchParams,\n            context: {\n              token: searchParams._authToken ?? getBearerToken(req.getHeader('authorization')),\n              headers,\n              ip: headers['x-real-ip'] ?? headers['x-forwarded-for'] ?? Buffer.from(res.getRemoteAddressAsText()).toString(),\n            }\n          },\n          req.getHeader('sec-websocket-key'),\n          req.getHeader('sec-websocket-protocol'),\n          req.getHeader('sec-websocket-extensions'),\n          context\n        );\n      },\n\n      open: async (ws: WebSocket<any>) => {\n        // ws.pingCount = 0;\n        await this.onConnection(ws as RawWebSocketClient);\n      },\n\n      // pong: (ws: RawWebSocketClient) => {\n      //     ws.pingCount = 0;\n      // },\n\n      close: (ws: WebSocket<any>, code: number, message: ArrayBuffer) => {\n        // remove from client list\n        spliceOne(this.clients, this.clients.indexOf(ws as RawWebSocketClient));\n\n        const clientWrapper = this.clientWrappers.get(ws as RawWebSocketClient);\n        if (clientWrapper) {\n          this.clientWrappers.delete(ws as RawWebSocketClient);\n\n          // emit 'close' on wrapper\n          clientWrapper.emit('close', code);\n        }\n      },\n\n      message: (ws: WebSocket<any>, message: ArrayBuffer, isBinary: boolean) => {\n        // emit 'message' on wrapper\n        this.clientWrappers.get(ws as RawWebSocketClient)?.emit('message', Buffer.from(message));\n      },\n\n    });\n  }\n\n  public getExpressApp(): Promise<express.Application> | express.Application {\n    if (!this._expressApp) {\n      return new Promise(async (resolve, reject) => {\n        try {\n          const module = await uWebSocketsExpress;\n          uWebSocketsExpressModule = module;\n          this._expressApp = (module.default(this.app) as unknown) as express.Application;\n          resolve(this._expressApp);\n        } catch (error) {\n          console.warn(\"\");\n          console.warn(\"\u274C Error: could not initialize express.\");\n          console.warn(\"\");\n          console.warn(\"    For Express v5, use:\");\n          console.warn(\"    \uD83D\uDC49 npm install --save uwebsockets-express@^2.0.1\");\n          console.warn(\"\");\n          console.warn(\"    For Express v4, use:\");\n          console.warn(\"    \uD83D\uDC49 npm install --save uwebsockets-express@^1.4.1\");\n          console.warn(\"\");\n          process.exit();\n        }\n      });\n    }\n    return this._expressApp;\n  }\n\n  public bindRouter(router: Router) {\n    const writeHeaders = (res: uWebSockets.HttpResponse, requestHeaders: Headers) => {\n      // skip if aborted\n      if (res.aborted) { return; }\n\n      const headers = Object.assign(\n        {},\n        matchMaker.controller.DEFAULT_CORS_HEADERS,\n        matchMaker.controller.getCorsHeaders(requestHeaders)\n      );\n\n      for (const header in headers) {\n        res.writeHeader(header, headers[header].toString());\n      }\n\n      return true;\n    }\n\n    this.app.options(\"/*\", (res, req) => {\n      res.onAborted(() => res.aborted = true);\n\n      // cache all headers\n      const reqHeaders = new Headers();\n      req.forEach((key, value) => reqHeaders.set(key, value));\n\n      if (writeHeaders(res, reqHeaders)) {\n        res.writeStatus(\"204 No Content\");\n        res.end();\n      }\n    });\n\n    this.app.any('/*', async (res, req) => {\n      const abortController = new AbortController();\n\n      res.onAborted(() => {\n        abortController.abort();\n        res.aborted = true;\n      });\n\n      const headers = new Headers();\n      req.forEach((key, value) => headers.set(key, value));\n\n      // write cors headers\n      writeHeaders(res, headers);\n\n      const requestInit: RequestInit = {\n        method: req.getMethod().toUpperCase(),\n        referrer: req.getHeader('referer'),\n        keepalive: req.getHeader('keep-alive') === 'true',\n        headers,\n        signal: abortController.signal,\n      };\n\n      // Construct full URL (Request constructor requires absolute URL)\n      const url = req.getUrl();\n      const query = req.getQuery();\n      const remoteAddress = res.getRemoteAddressAsText();\n\n      // read request body\n      if (requestInit.method.toUpperCase() !== \"GET\" && requestInit.method.toUpperCase() !== \"HEAD\") {\n        let body: Buffer = undefined;\n\n        // uWebSockets.js `HttpRequest` does not provide 'getData', must aggregate POST body via HttpResponse\n        await new Promise<void>((resolve) => {\n          res.onData((ab, isLast) => {\n            const chunk = Buffer.from(ab);\n            if (body === undefined) {\n              body = Buffer.from(chunk);\n            } else {\n              body = Buffer.concat([body, chunk]);\n            }\n            if (isLast) {\n              resolve();\n            }\n          });\n        });\n\n        requestInit.body = body.buffer.slice(body.byteOffset, body.byteOffset + body.byteLength) as ArrayBuffer;\n      }\n\n      const fullUrl = `http://${headers.get('host') || 'localhost'}${url}${(query ? `?${query}` : '')}`\n      const response = await router.handler(new Request(fullUrl, requestInit));\n\n      // fallback to express stack if 404\n      if (response.status === 404 && this._expressApp) {\n        const ereq = new uWebSocketsExpressModule.IncomingMessage(req, res, this._expressApp as any, {\n          headers: Object.fromEntries((headers as any).entries()),\n          method: requestInit.method,\n          url,\n          query,\n          remoteAddress\n        });\n        const eres = new uWebSocketsExpressModule.ServerResponse(res, req, this._expressApp);\n        this._expressApp['handle'](ereq, eres);\n        return;\n      }\n\n      // skip if aborted\n      if (res.aborted) { return; }\n\n      // read response body before cork (cork callback must be synchronous)\n      const responseBody = await response.arrayBuffer();\n\n      res.cork(() => {\n        res.writeStatus(`${response.status} ${response.statusText}`);\n        response.headers.forEach((value, key) => {\n          res.writeHeader(key, value);\n        });\n        res.end(responseBody);\n      });\n    });\n  }\n\n  public listen(port: number, hostname?: string, backlog?: number, listeningListener?: () => void) {\n    const callback = (listeningSocket: any) => {\n      this._listeningSocket = listeningSocket;\n      listeningListener?.();\n    };\n\n    if (typeof (port) === \"string\") {\n      this.app.listen_unix(callback, port);\n\n    } else {\n      this.app.listen(port, callback);\n\n    }\n    return this;\n  }\n\n  public shutdown() {\n    if (this._listeningSocket) {\n      uWebSockets.us_listen_socket_close(this._listeningSocket);\n    }\n  }\n\n  public simulateLatency(milliseconds: number) {\n    if (this._originalRawSend == null) {\n      this._originalRawSend = uWebSocketClient.prototype.raw;\n    }\n\n    const originalRawSend = this._originalRawSend;\n    uWebSocketClient.prototype.raw = milliseconds <= Number.EPSILON ? originalRawSend : function (...args: any[]) {\n      // copy buffer\n      let [buf, ...rest] = args;\n      buf = Buffer.from(buf);\n      // @ts-ignore\n      setTimeout(() => originalRawSend.apply(this, [buf, ...rest]), milliseconds);\n    };\n  }\n\n  protected async onConnection(rawClient: RawWebSocketClient) {\n    const wrapper = new uWebSocketWrapper(rawClient);\n    // keep reference to client and its wrapper\n    this.clients.push(rawClient);\n    this.clientWrappers.set(rawClient, wrapper);\n\n    const url = rawClient.url;\n    const searchParams = rawClient.searchParams;\n\n    const sessionId = searchParams.sessionId as string;\n    const processAndRoomId = url.match(/\\/[a-zA-Z0-9_\\-]+\\/([a-zA-Z0-9_\\-]+)$/);\n    const roomId = processAndRoomId && processAndRoomId[1];\n\n    // If sessionId is not provided, allow ping-pong utility.\n    if (!sessionId && !roomId) {\n      // Disconnect automatically after 1 second if no message is received.\n      const timeout = setTimeout(() => rawClient.close(), 1000);\n      wrapper.on('message', (_) => rawClient.send(new Uint8Array([Protocol.PING]), true));\n      wrapper.on('close', () => clearTimeout(timeout));\n      return;\n    }\n\n    const room = matchMaker.getLocalRoomById(roomId);\n    const client = new uWebSocketClient(sessionId, wrapper);\n    const reconnectionToken = searchParams.reconnectionToken as string;\n    const skipHandshake = (searchParams.skipHandshake !== undefined);\n\n    try {\n      await connectClientToRoom(room, client, rawClient.context, {\n        reconnectionToken,\n        skipHandshake\n      });\n\n    } catch (e: any) {\n      debugAndPrintError(e);\n\n      // send error code to client then terminate\n      client.error(e.code, e.message, () => client.leave());\n    }\n  }\n\n  // protected registerMatchMakeRequest() {\n  //   const matchmakeRoute = 'matchmake';\n  //   const allowedRoomNameChars = /([a-zA-Z_\\-0-9]+)/gi;\n\n  //   const writeHeaders = (res: uWebSockets.HttpResponse, requestHeaders: Headers) => {\n  //     // skip if aborted\n  //     if (res.aborted) { return; }\n\n  //     const headers = Object.assign(\n  //       {},\n  //       matchMaker.controller.DEFAULT_CORS_HEADERS,\n  //       matchMaker.controller.getCorsHeaders(requestHeaders)\n  //     );\n\n  //     for (const header in headers) {\n  //       res.writeHeader(header, headers[header].toString());\n  //     }\n\n  //     return true;\n  //   }\n\n  //   const writeError = (res: uWebSockets.HttpResponse, error: { code: number, error: string }) => {\n  //     // skip if aborted\n  //     if (res.aborted) { return; }\n\n  //     res.cork(() => {\n  //       res.writeStatus(\"406 Not Acceptable\");\n  //       res.end(JSON.stringify(error));\n  //     });\n  //   }\n\n  //   const onAborted = (res: uWebSockets.HttpResponse) => {\n  //     res.aborted = true;\n  //   };\n\n  //   this.app.options(\"/matchmake/*\", (res, req) => {\n  //     res.onAborted(() => onAborted(res));\n\n  //     // cache all headers\n  //     const reqHeaders = new Headers();\n  //     req.forEach((key, value) => reqHeaders.set(key, value));\n\n  //     if (writeHeaders(res, reqHeaders)) {\n  //       res.writeStatus(\"204 No Content\");\n  //       res.end();\n  //     }\n  //   });\n\n\n  //   // @ts-ignore\n  //   this.app.post(\"/matchmake/*\", (res, req) => {\n  //     res.onAborted(() => onAborted(res));\n\n  //     // do not accept matchmaking requests if already shutting down\n  //     if (matchMaker.state === matchMaker.MatchMakerState.SHUTTING_DOWN) {\n  //       return res.close();\n  //     }\n\n  //     // cache all headers\n  //     const headers = new Headers();\n  //     req.forEach((key, value) => headers.set(key, value));\n\n  //     writeHeaders(res, headers);\n  //     res.writeHeader('Content-Type', 'application/json');\n\n  //     const url = req.getUrl();\n  //     const matchedParams = url.match(allowedRoomNameChars);\n  //     const matchmakeIndex = matchedParams.indexOf(matchmakeRoute);\n\n  //     const token = getBearerToken(headers['authorization']);\n\n  //     // read json body\n  //     this.readJson(res, async (clientOptions) => {\n  //       try {\n  //         if (clientOptions === undefined) {\n  //           throw new Error(\"invalid JSON input\");\n  //         }\n\n  //         const method = matchedParams[matchmakeIndex + 1];\n  //         const roomName = matchedParams[matchmakeIndex + 2] || '';\n\n  //         const response = await matchMaker.controller.invokeMethod(\n  //           method,\n  //           roomName,\n  //           clientOptions,\n  //           {\n  //             token,\n  //             headers,\n  //             ip: headers.get('x-real-ip') ?? headers.get('x-forwarded-for') ?? Buffer.from(res.getRemoteAddressAsText()).toString()\n  //           }\n  //         );\n\n  //         if (!res.aborted) {\n  //           res.cork(() => {\n  //             res.writeStatus(\"200 OK\");\n  //             res.end(JSON.stringify(response));\n  //           });\n  //         }\n\n  //       } catch (e: any) {\n  //         debugAndPrintError(e);\n  //         writeError(res, {\n  //           code: e.code || ErrorCode.MATCHMAKE_UNHANDLED,\n  //           error: e.message\n  //         });\n  //       }\n\n  //     });\n  //   });\n  // }\n\n  /* Helper function for reading a posted JSON body */\n  /* Extracted from https://github.com/uNetworking/uWebSockets.js/blob/master/examples/JsonPost.js */\n  private readJson(res: uWebSockets.HttpResponse, cb: (json: any) => void) {\n    let buffer: Buffer;\n    /* Register data cb */\n    res.onData((ab, isLast) => {\n      let chunk = Buffer.from(ab);\n      if (isLast) {\n        let json;\n        if (buffer) {\n          try {\n            // @ts-ignore\n            json = JSON.parse(Buffer.concat([buffer, chunk]));\n          } catch (e) {\n            /* res.close calls onAborted */\n            // res.close();\n            cb(undefined);\n            return;\n          }\n          cb(json);\n        } else {\n          try {\n            // @ts-ignore\n            json = JSON.parse(chunk);\n          } catch (e) {\n            /* res.close calls onAborted */\n            // res.close();\n            cb(undefined);\n            return;\n          }\n          cb(json);\n        }\n      } else {\n        if (buffer) {\n          buffer = Buffer.concat([buffer, chunk]);\n        } else {\n          buffer = Buffer.concat([chunk]);\n        }\n      }\n    });\n  }\n}\n"],
  "mappings": "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",
  "names": ["import_core", "module", "uWebSockets", "querystring"]
}
