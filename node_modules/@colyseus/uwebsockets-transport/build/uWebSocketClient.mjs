// packages/transport/uwebsockets-transport/src/uWebSocketClient.ts
import EventEmitter from "events";
import "uWebSockets.js";
import { getMessageBytes, Protocol, ClientState, logger, debugMessage } from "@colyseus/core";
var uWebSocketWrapper = class extends EventEmitter {
  constructor(ws) {
    super();
    this.ws = ws;
  }
};
var ReadyState = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};
var uWebSocketClient = class {
  constructor(id, _ref) {
    this.state = ClientState.JOINING;
    this.readyState = ReadyState.OPEN;
    this._enqueuedMessages = [];
    this.id = this.sessionId = id;
    this._ref = _ref;
    _ref.on("close", () => this.readyState = ReadyState.CLOSED);
  }
  get ref() {
    return this._ref;
  }
  set ref(_ref) {
    this._ref = _ref;
    this.readyState = ReadyState.OPEN;
  }
  sendBytes(type, bytes, options) {
    debugMessage("send bytes(to %s): '%s' -> %j", this.sessionId, type, bytes);
    this.enqueueRaw(
      getMessageBytes.raw(Protocol.ROOM_DATA_BYTES, type, void 0, bytes),
      options
    );
  }
  send(messageOrType, messageOrOptions, options) {
    debugMessage("send(to %s): '%s' -> %O", this.sessionId, messageOrType, messageOrOptions);
    this.enqueueRaw(
      getMessageBytes.raw(Protocol.ROOM_DATA, messageOrType, messageOrOptions),
      options
    );
  }
  enqueueRaw(data, options) {
    if (options?.afterNextPatch) {
      this._afterNextPatchQueue.push([this, [data]]);
      return;
    }
    if (this.state === ClientState.JOINING) {
      this._enqueuedMessages.push(data);
      return;
    }
    this.raw(data, options);
  }
  raw(data, options, cb) {
    if (this.readyState !== ReadyState.OPEN) {
      return;
    }
    this._ref.ws.send(data, true, false);
  }
  error(code, message = "", cb) {
    this.raw(getMessageBytes[Protocol.ERROR](code, message));
    if (cb) {
      setTimeout(cb, 1);
    }
  }
  leave(code, data) {
    if (this.readyState !== ReadyState.OPEN) {
      return;
    }
    this.readyState = ReadyState.CLOSING;
    if (code !== void 0) {
      this._ref.ws.end(code, data);
    } else {
      this._ref.ws.close();
    }
  }
  close(code, data) {
    logger.warn("DEPRECATION WARNING: use client.leave() instead of client.close()");
    try {
      throw new Error();
    } catch (e) {
      logger.info(e.stack);
    }
    this.leave(code, data);
  }
  toJSON() {
    return { sessionId: this.sessionId, readyState: this.readyState };
  }
};
export {
  ReadyState,
  uWebSocketClient,
  uWebSocketWrapper
};
