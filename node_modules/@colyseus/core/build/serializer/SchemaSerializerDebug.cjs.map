{
  "version": 3,
  "sources": ["../../src/serializer/SchemaSerializerDebug.ts"],
  "sourcesContent": ["/**\n * This serializer is a copy of SchemaSerializer,\n * but it writes debug information to a file.\n *\n * This script must be used\n */\n\nimport fs from 'fs';\nimport { Schema, dumpChanges, Iterator } from '@colyseus/schema';\nimport { SchemaSerializer } from './SchemaSerializer.ts';\nimport { Client, ClientState  } from \"../Transport.ts\";\nimport { Protocol} from '../Protocol.ts';\nimport { debugPatch } from '../Debug.ts';\n\n/*\nconst SHARED_VIEW = {};\n\nexport class SchemaSerializerDebug<T> extends SchemaSerializer<T> {\n  protected debugStream: fs.WriteStream;\n\n  constructor(fileName: string = \"schema-debug.txt\") {\n    super();\n\n    try { fs.unlinkSync(fileName); } catch (e) {}\n    this.debugStream = fs.createWriteStream(fileName, { flags: \"a\" });\n  }\n\n  public getFullState(client?: Client): Buffer {\n    const buf = super.getFullState(client);\n    this.debugStream.write(`state:${client.sessionId}:${Array.from(buf).slice(1).join(\",\")}\\n`);\n    return buf;\n  }\n\n  public applyPatches(clients: Client[]) {\n    let numClients = clients.length;\n\n    const debugChangesDeep = Schema.debugChangesDeep(this.encoder.state);\n\n    if (\n      numClients == 0 ||\n      (\n        this.encoder.root.changes.size === 0 &&\n        (!this.hasFilters || this.encoder.root.filteredChanges.size === 0)\n      )\n    ) {\n      // skip patching state if:\n      // - no clients are connected\n      // - no changes were made\n      // - no \"filtered changes\" were made when using filters\n      return false;\n    }\n\n    this.needFullEncode = true;\n\n    // dump changes for patch debugging\n    if (debugPatch.enabled) {\n      (debugPatch as any).dumpChanges = dumpChanges(this.encoder.state);\n    }\n\n    // get patch bytes\n    const it: Iterator = { offset: 1 };\n    this.encoder.sharedBuffer[0] = Protocol.ROOM_STATE_PATCH;\n\n    // encode changes once, for all clients\n    const encodedChanges = this.encoder.encode(it);\n\n    if (!this.hasFilters) {\n      while (numClients--) {\n        const client = clients[numClients];\n\n        //\n        // FIXME: avoid this check for each client\n        //\n        if (client.state !== ClientState.JOINED) {\n          continue;\n        }\n\n        debugChangesDeep.split(\"\\n\").forEach((line) => {\n          this.debugStream.write(`#${client.sessionId}:${line}\\n`);\n        });\n        this.debugStream.write(`patch:${client.sessionId}:${Array.from(encodedChanges).slice(1).join(\",\")}\\n`);\n\n        client.raw(encodedChanges);\n      }\n\n    } else {\n      // cache shared offset\n      const sharedOffset = it.offset;\n\n      // encode state multiple times, for each client\n      while (numClients--) {\n        const client = clients[numClients];\n\n        //\n        // FIXME: avoid this check for each client\n        //\n        if (client.state !== ClientState.JOINED) {\n          continue;\n        }\n\n        const view = client.view || SHARED_VIEW;\n\n        let encodedView = this.views.get(view);\n\n        // allow to pass the same encoded view for multiple clients\n        if (encodedView === undefined) {\n          encodedView = (view === SHARED_VIEW)\n            ? encodedChanges\n            : this.encoder.encodeView(client.view, sharedOffset, it);\n          this.views.set(view, encodedView);\n        }\n\n        debugChangesDeep.split(\"\\n\").forEach((line) => {\n          this.debugStream.write(`#${client.sessionId}:${line}\\n`);\n        });\n        this.debugStream.write(`patch:${client.sessionId}:${Array.from(encodedView).slice(1).join(\",\")}\\n`);\n\n        client.raw(encodedView);\n      }\n\n      // clear views\n      this.views.clear();\n    }\n\n    // discard changes after sending\n    this.encoder.discardChanges();\n\n    // debug patches\n    if (debugPatch.enabled) {\n      debugPatch(\n        '%d bytes sent to %d clients, %j',\n        encodedChanges.length,\n        clients.length,\n        (debugPatch as any).dumpChanges,\n      );\n    }\n\n    return true;\n  }\n\n  public handshake(): Buffer {\n    const buf = super.handshake();\n    this.debugStream.write(`handshake:${Array.from(buf).join(\",\")}\\n`);\n    return buf;\n  }\n}\n\n*/"],
  "mappings": ";;;AAOA,gBAAe;AACf,oBAA8C;AAC9C,8BAAiC;AACjC,uBAAqC;AACrC,sBAAwB;AACxB,mBAA2B;",
  "names": []
}
